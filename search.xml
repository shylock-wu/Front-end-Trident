<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NuxtJS学习专栏</title>
      <link href="/2023/11/11/NuxtStudy/index/"/>
      <url>/2023/11/11/NuxtStudy/index/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Nuxt.js是一个基于Vue.js的通用应用框架，类似于NextJS，但是它是基于React的。可不要搞混了NuxtJS和NextJS哦。简单来说就是NuxtJS提供了一种直观且可扩展的方式来创建<code>类型安全</code>、<code>高性能</code>和<code>生产级别</code>的<code>全栈</code>Web应用和网站，它做了一切，从一开始就可以编写.vue文件，同时在开发中享受到热模块替换的便利，并在生产中获得高性能的应用，其中默认启用了<code>服务器端渲染</code>。</p><ol><li>自动化和约定</li><li>服务端渲染</li></ol><p><a href="https://nuxt.com/docs/getting-started/introduction">英文文档</a><br><a href="https://nuxt.com.cn/docs/getting-started/introduction">中文文档</a></p><h1 id="2-安装初始化项目"><a href="#2-安装初始化项目" class="headerlink" title="2. 安装初始化项目"></a>2. 安装初始化项目</h1><p>这里就使用pnpm来管理包。需要Node.js - v16.10.0 或更高版本(最好是偶数版本)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm dlx nuxi@latest init nuxt-demo<br></code></pre></td></tr></table></figure><p>使用vscode打开项目，然后安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在运行 pnpm install 之前，请确保在 `.npmrc` 中设置了 `shamefully-hoist=true`</span><br>pnpm install<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NuxtJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js中关于数组的使用</title>
      <link href="/2023/04/18/JavaScript/Array/"/>
      <url>/2023/04/18/JavaScript/Array/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>为什么我要单独写一篇文章来记录和说明js中数组相关方法的使用，是因为我发现在使用这些方法的过程中，总是有模糊和遗忘的地方，这里仅记录部分数组方法，如需查看更多请点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">MDN</a>。</p><p>在JavaScript中，数组是一种常用的数据结构，常常需要对数组进行添加、删除、修改、查找等操作。在进行这些操作时，有一些数组方法会直接修改原数组，而有一些则不会。</p><h1 id="是否影响原数组"><a href="#是否影响原数组" class="headerlink" title="是否影响原数组"></a>是否影响原数组</h1><h2 id="会影响"><a href="#会影响" class="headerlink" title="会影响"></a>会影响</h2><h3 id="push-element0-element1-x2F-…-x2F-elementN-：将一个或多个元素添加到数组末尾，并返回新数组的长度。"><a href="#push-element0-element1-x2F-…-x2F-elementN-：将一个或多个元素添加到数组末尾，并返回新数组的长度。" class="headerlink" title="push(element0, element1, &#x2F;* … ,*&#x2F; elementN)：将一个或多个元素添加到数组末尾，并返回新数组的长度。"></a>push(element0, element1, &#x2F;* … ,*&#x2F; elementN)：将一个或多个元素添加到数组末尾，并返回新数组的长度。</h3><blockquote><p>参数：elementN：被添加到数组末尾的元素。<br>返回值：新的<code>length</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="pop-：从数组末尾删除一个元素，并返回该元素的值。"><a href="#pop-：从数组末尾删除一个元素，并返回该元素的值。" class="headerlink" title="pop()：从数组末尾删除一个元素，并返回该元素的值。"></a>pop()：从数组末尾删除一个元素，并返回该元素的值。</h3><blockquote><p>参数：无<br>返回值：从数组中删除的元素（当数组为空时返回undefined）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 注意返回的是被删除的元素3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="shift-element0-element1-x2F-…-x2F-elementN-：从数组开头删除一个元素，并返回该元素的值。"><a href="#shift-element0-element1-x2F-…-x2F-elementN-：从数组开头删除一个元素，并返回该元素的值。" class="headerlink" title="shift(element0, element1, &#x2F;* … ,*&#x2F; elementN)：从数组开头删除一个元素，并返回该元素的值。"></a>shift(element0, element1, &#x2F;* … ,*&#x2F; elementN)：从数组开头删除一个元素，并返回该元素的值。</h3><blockquote><p>参数：elementN，要添加到数组开头的元素。<br>返回值：从数组中删除的元素; 如果数组为空则返回undefined 。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">// 注意返回的是被删除的元素1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="unshift-：将一个或多个元素添加到数组开头，并返回新数组的长度。"><a href="#unshift-：将一个或多个元素添加到数组开头，并返回新数组的长度。" class="headerlink" title="unshift()：将一个或多个元素添加到数组开头，并返回新数组的长度。"></a>unshift()：将一个或多个元素添加到数组开头，并返回新数组的长度。</h3><blockquote><p>参数：无<br>返回值：新的<code>length</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> length = arr.<span class="hljs-title function_">unshift</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr,length) <span class="hljs-comment">// [-1, 0, 1, 2, 3] 5</span><br></code></pre></td></tr></table></figure><h3 id="splice-start-deleteCount-item1-item2-itemN-：从指定位置开始修改原数组，可以删除、添加、替换元素。"><a href="#splice-start-deleteCount-item1-item2-itemN-：从指定位置开始修改原数组，可以删除、添加、替换元素。" class="headerlink" title="splice(start, deleteCount, item1, item2, itemN)：从指定位置开始修改原数组，可以删除、添加、替换元素。"></a>splice(start, deleteCount, item1, item2, itemN)：从指定位置开始修改原数组，可以删除、添加、替换元素。</h3><blockquote><ol><li>index: 必需。规定要添加、删除或替换的数组元素的起始位置。</li><li>deleteCount: 可选。规定要删除的数组元素的数量。如果设置为0，则不删除任何元素。</li><li>item1, …, itemX: 可选。规定要添加到数组的新元素。<br>返回值：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</li></ol></blockquote><p>例如，以下代码将在数组arr的第二个位置插入一个字符串”insert”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;insert&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, &quot;insert&quot;, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>再例如，以下代码将删除数组arr的第二个和第三个元素:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 4]</span><br></code></pre></td></tr></table></figure><h3 id="sort-compareFn-：对原数组进行排序（直接修改原数组）。"><a href="#sort-compareFn-：对原数组进行排序（直接修改原数组）。" class="headerlink" title="sort(compareFn)：对原数组进行排序（直接修改原数组）。"></a>sort(compareFn)：对原数组进行排序（直接修改原数组）。</h3><blockquote><p>参数：compareFn(a,b)：可选，用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的 Unicode 位点进行排序。a: 第一个用于比较的元素,b: 第二个用于比较的元素。</p></blockquote><p>如果没有指明 compareFn ，那么元素会按照转换为的字符串的诸个字符的 Unicode 位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFn），比较的数字会先被转换为字符串，所以在 Unicode 顺序上 “80” 要比 “9” 要<mark class="hl-label red">靠前</mark> 。</p><blockquote><p>返回值：排序后的数组。请注意，数组已原地排序，并且不进行复制。</p></blockquote><table><thead><tr><th align="center">compareFn(a, b)  返回值</th><th align="center">排序顺序</th></tr></thead><tbody><tr><td align="center">&gt; 0</td><td align="center"><code>a</code>在<code>b</code>后</td></tr><tr><td align="center">&lt; 0</td><td align="center"><code>a</code>在<code>b</code>前</td></tr><tr><td align="center">&#x3D;&#x3D;&#x3D; 0</td><td align="center">保持<code>a</code>和<code>b</code>的顺序</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">sort</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><h3 id="reverse-：反转原数组（直接修改原数组）。"><a href="#reverse-：反转原数组（直接修改原数组）。" class="headerlink" title="reverse()：反转原数组（直接修改原数组）。"></a>reverse()：反转原数组（直接修改原数组）。</h3><blockquote><p>参数：无<br>返回值：颠倒后的数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// [1, 2, 3]</span><br><br>a.<span class="hljs-title function_">reverse</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure><h3 id="fill-value-start-end-：使用给定值填充整个数组或一段区间（直接修改原数组）。"><a href="#fill-value-start-end-：使用给定值填充整个数组或一段区间（直接修改原数组）。" class="headerlink" title="fill(value, start, end)：使用给定值填充整个数组或一段区间（直接修改原数组）。"></a>fill(value, start, end)：使用给定值填充整个数组或一段区间（直接修改原数组）。</h3><blockquote><p>value：用来填充数组元素的值。注意所有数组中的元素都将是这个确定的值：如果 value 是个对象，那么数组的每一项都会引用这个元素。<br>start 可选<br>end 可选</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// [4, 4, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// [1, 4, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// [1, 4, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>)); <span class="hljs-comment">// [4, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// [4, 4, 4]</span><br><br><span class="hljs-comment">// 一个简单的对象，被数组的每个空槽所引用</span><br><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(&#123;&#125;); <span class="hljs-comment">// [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br>arr[<span class="hljs-number">0</span>].<span class="hljs-property">hi</span> = <span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// [&#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;]</span><br></code></pre></td></tr></table></figure><mark class="hl-label green">需要注意的是</mark> ，这些方法都是直接修改原数组的，因此在使用时应当谨慎，以免不小心修改了原数组的值导致程序出现错误。<h2 id="不会影响"><a href="#不会影响" class="headerlink" title="不会影响"></a>不会影响</h2><h1 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Salesforce之JavaScript学习一</title>
      <link href="/2023/04/17/salesforce/index/"/>
      <url>/2023/04/17/salesforce/index/</url>
      
        <content type="html"><![CDATA[<h1 id="注册Salesforce账号"><a href="#注册Salesforce账号" class="headerlink" title="注册Salesforce账号"></a>注册Salesforce账号</h1><p>去到这个<a href="https://trailhead.salesforce.com/zh-CN/">网站</a>进行注册然后学习，在学习的时候会有对Salesforce平台的了解程度有要求，因此有一定的学习成本，对于新手小白来说并不友好。<br>之所以写这篇文章仅仅是为了简单的记录一下学习的心路历程。</p><h1 id="选择证书"><a href="#选择证书" class="headerlink" title="选择证书"></a>选择证书</h1><p>点击左上角的证书选项，点击认证，随后选择相应的角色Role进行学习，作为一个Salesforce Developer，点击它就好了，在呈现的Developer Credentials中选择JavaScript Developer I。卡片右上角是考试的网站，点击进去需要注册认证并花费部分money才能获取考试资格。</p><h1 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h1><p>直接点击卡片内容，可以看到Study &amp; Prepare，这应该就是我需要学习的内容，基本上考试的内容也是在这里面。此证书分为两个模块，两个模块测试通过后自动获取该证书。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用局域网连接Node容器和MySQL服务器</title>
      <link href="/2023/04/06/Docker/NodeAndMysql/"/>
      <url>/2023/04/06/Docker/NodeAndMysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>需求：现在要求使用Docker，在Node18的容器里面链接MySQL容器的数据库</p></blockquote><h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><h2 id="Mysql镜像"><a href="#Mysql镜像" class="headerlink" title="Mysql镜像"></a>Mysql镜像</h2><p>由于我使用的是M1芯片的电脑，结构为ARM64，所以在拉取MySQL镜像的时候需要特别注意对应的版本，而且截止目前为止，我看到的支持M1芯片的MySQL版本只有8，所以默认下载MySQL8。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull arm64v8/mysql<br></code></pre></td></tr></table></figure><h2 id="Node18镜像"><a href="#Node18镜像" class="headerlink" title="Node18镜像"></a>Node18镜像</h2><p>拉取node镜像的时候，可以使用arm64&#x2F;v8标签的镜像，使用冒号指定版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull arm64v8/node:18<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS M2 安装MySQL服务</title>
      <link href="/2023/03/30/MySql/index/"/>
      <url>/2023/03/30/MySql/index/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h1><p>这里应该需要在终端开启代理才能访问。<br><img src="https://s1.ax1x.com/2023/03/30/pp2K1NF.png" alt="pp2K1NF.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>然后在终端输入命令查看版本，用来确定安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew -v<br></code></pre></td></tr></table></figure><h1 id="安装指定版本的MySQL"><a href="#安装指定版本的MySQL" class="headerlink" title="安装指定版本的MySQL"></a>安装指定版本的MySQL</h1><h2 id="这里安装MySql-5-7"><a href="#这里安装MySql-5-7" class="headerlink" title="这里安装MySql 5.7"></a>这里安装MySql 5.7</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install mysql@5.7<br></code></pre></td></tr></table></figure><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>安装完成会有类似于这样的文字出现</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">If you need to have mysql@5.7 first <span class="hljs-keyword">in</span> your PATH, run:<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=&quot;/opt/homebrew/opt/mysql@5.7/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><p>然后输入<mark class="hl-label blue">这里可能有变化，请输入自己终端显示的内容</mark> </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=&quot;/opt/homebrew/opt/mysql@5.7/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><h2 id="开启mysql服务"><a href="#开启mysql服务" class="headerlink" title="开启mysql服务"></a>开启mysql服务</h2><p>新开一个终端，输入命令开启服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql.server start<br></code></pre></td></tr></table></figure><p>类似的还有停止服务，重启服务，查看服务状态</p><ol><li>mysql.server stop</li><li>mysql.server restart</li><li>mysql.server status</li></ol><h1 id="设置MySQL登录密码"><a href="#设置MySQL登录密码" class="headerlink" title="设置MySQL登录密码"></a>设置MySQL登录密码</h1><ol><li>使用以下命令来连接MySQL服务器：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql -u root<br></code></pre></td></tr></table></figure></li><li>然后执行以下命令来设置root用户的密码：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;new_password&#x27;</span>;<br></code></pre></td></tr></table></figure><code>new_password</code>就是新密码</li></ol><h2 id="测试登录"><a href="#测试登录" class="headerlink" title="测试登录"></a>测试登录</h2><p>使用密码登录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql -u root -p<br></code></pre></td></tr></table></figure><p>然后输入密码</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker Desktop创建容器</title>
      <link href="/2023/03/30/Docker/index/"/>
      <url>/2023/03/30/Docker/index/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Docker-Desktop"><a href="#安装Docker-Desktop" class="headerlink" title="安装Docker Desktop"></a>安装Docker Desktop</h1><ol><li><p>首先去<a href="https://docs.docker.com/get-docker/">官网</a>进行下载，选择你的电脑系统进行下载安装。</p><blockquote><p>这里国内访问可能有点慢，可使用🪜</p></blockquote><!-- ![ppg5RP0.md.png](https://imgse.com/i/ppg5RP0) --><p><img src="https://s1.ax1x.com/2023/03/30/ppg5RP0.png" alt="ppg5RP0.png"></p></li><li><p>测试安装的成功与否<br>打开终端，输入以下命令查看docker的版本，能够显示就说明安装成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -v<br></code></pre></td></tr></table></figure></li></ol><h1 id="构建Node映像"><a href="#构建Node映像" class="headerlink" title="构建Node映像"></a>构建Node映像</h1><h2 id="为Node-js创建一个Dockerfile"><a href="#为Node-js创建一个Dockerfile" class="headerlink" title="为Node.js创建一个Dockerfile"></a>为Node.js创建一个Dockerfile</h2><p>接下来，我们需要在Dockerfile中添加一行，告诉Docker应用程序将使用哪个基本映像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine<br></code></pre></td></tr></table></figure><p>Docker镜像可以从其他镜像继承。因此，我们将使用官方的Node.js镜像，而不是创建我们自己的基本镜像，它已经拥有运行Node.js应用程序所需的所有工具和包。您可以用与面向对象编程中的类继承相同的方式来考虑这个问题。例如，如果我们能够在JavaScript中创建Docker镜像，我们可能会编写如下内容。<br><code>class MyImage extends NodeBaseImage &#123;&#125;</code><br>这将创建一个名为<code>MyImage</code>的类，它继承了基类<code>NodeBaseImage</code>的功能。<br>以同样的方式，当我们使用<code>FROM</code>命令时，我们告诉Docker在我们的镜像中包含所有来自<code>node:18-alpine</code>的功能。</p><div class="note info flat"><p>如果您想了解关于创建自己的基本镜像的更多信息，请参见<a href="https://docs.docker.com/build/building/base-images/">创建基本镜像</a>。</p></div><p><code>NODE_ENV</code>环境变量指定应用程序运行的环境(通常是开发环境或生产环境)。提高性能的最简单方法之一是将<code>NODE_ENV</code>设置为<code>生产环境(production)</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">ENV</span> NODE_ENV=production<br></code></pre></td></tr></table></figure><p>为了使运行其余命令更容易，让我们创建一个工作目录。这指示Docker使用此路径作为所有后续命令的默认位置。这样我们就不需要输入完整的文件路径，而是可以使用基于工作目录的相对路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br></code></pre></td></tr></table></figure><p>通常当你下载了一个用Node.js编写的项目后，你要做的第一件事就是安装npm包。这确保您的应用程序将其所有依赖项安装到<code>node_modules</code>目录中，Node运行时将能够在其中找到它们。<br>在运行<code>npm install</code>之前，我们需要将<code>package.json</code>和<code>package-lock.json</code>文件放入我们的镜像中。<br>我们使用<code>COPY</code>命令来执行此操作。<code>COPY</code>命令有两个参数：<code>src</code>和<code>dest</code>。第一个参数<code>src</code>告诉Docker要将哪个文件复制到镜像中。第二个参数<code>dest</code>告诉Docker要将该文件复制到哪里。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>您可以指定多个用逗号分隔的<code>src</code>资源。例如，<code>COPY[&quot;&lt;src1&gt;&quot;，&quot;&lt;src2&gt;&quot;，…，&quot;&lt;est&gt;&quot;]</code>。我们将把<code>package.json</code>和<code>package-lock.json</code>文件复制到我们的工作目录中<code>/app</code>.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;package.json&quot;</span>, <span class="hljs-string">&quot;package-lock.json*&quot;</span>, <span class="hljs-string">&quot;./&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>请注意，我们不是复制整个工作目录，而是只复制package.json文件。这允许我们利用缓存的Docker层。一旦我们的文件在镜像中，我们就可以使用<code>RUN</code>命令执行命令npm install。这与我们在机器上本地运行npm install完全相同，但这次这些节点模块将安装到图像内的<code>node_modules</code>目录中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install --production</span><br></code></pre></td></tr></table></figure><p>此时，我们有一个基于<code>node 18</code>的镜像，并且我们已经安装了依赖项。接下来我们需要做的是将源码添加到图像中。我们将使用COPY命令，就像我们对上面的<code>package. json</code>文件所做的那样。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br></code></pre></td></tr></table></figure><p>COPY命令获取当前目录中的所有文件并将它们复制到映像中。现在，我们所要做的就是告诉Docker，当我们的映像在容器中运行时，我们要运行什么命令。我们使用CMD命令来执行此操作。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;server.js&quot;</span> ]</span><br></code></pre></td></tr></table></figure><p>这是完整的Dockerfile。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine<br><span class="hljs-keyword">ENV</span> NODE_ENV=production<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;package.json&quot;</span>, <span class="hljs-string">&quot;package-lock.json*&quot;</span>, <span class="hljs-string">&quot;./&quot;</span>]</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install --production</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;server.js&quot;</span> ]</span><br></code></pre></td></tr></table></figure><h2 id="创建一个-dockerignore文件"><a href="#创建一个-dockerignore文件" class="headerlink" title="创建一个.dockerignore文件"></a>创建一个.dockerignore文件</h2><p>要在<a href="https://docs.docker.com/build/building/context/">构建上下文中</a>使用文件，Dockerfile引用指令中指定的文件，例如COPY指令。<code>.dockerignore</code>文件允许您指定要从构建上下文中排除的文件和目录。要提高构建性能，请创建一个<code>.dockerignore</code>文件并在其中添加<code>node_modules</code>目录：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile">node_modules<br></code></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>现在我们已经创建了Dockerfile，让我们构建图像。为此，我们使用<code>docker build</code>命令。<code>docker build</code>命令从Dockerfile和“上下文”构建Docker图像。构建的上下文是位于指定PATH或URL中的文件集。Docker构建过程可以访问上下文中的任何文件。</p><p>构建命令可以选择使用<code>--tag</code>标志。标签用于设置图像的名称和格式为<code>&#39;name:tag&#39;</code>的可选标签。为了简化事情，我们暂时不使用可选的“tag”。如果你没有传递一个标签，Docker将使用“latest”作为它的默认标签。您将在构建输出的最后一行中看到这一点。</p><p>让我们构建第一个Docker镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build --tag node-docker .<br><br>[+] Building 93.8s (11/11) FINISHED<br> =&gt; [internal] load build definition from dockerfile                                          0.1s<br> =&gt; =&gt; transferring dockerfile: 617B                                                          0.0s<br> =&gt; [internal] load .dockerignore                                                             0.0s<br> ...<br> =&gt; [2/5] WORKDIR /app                                                                        0.4s<br> =&gt; [3/5] COPY [package.json, package-lock.json*, ./]                                         0.2s<br> =&gt; [4/5] RUN npm install --production                                                        9.8s<br> =&gt; [5/5] COPY . .<br></code></pre></td></tr></table></figure><h2 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h2><p>要查看本地机器上的图像列表，有两个选项。一种是使用CLI，另一种是使用Docker Desktop。由于我们目前正在终端中工作，让我们看看如何使用CLI列出图像。<br>要列出镜像，只需运行<code>images</code>命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE<br>node-docker         latest              3809733582bc        About a minute ago   945MB<br></code></pre></td></tr></table></figure><p>确切的输出可能会有所不同，但是能够看到刚刚创建的带有<code>latest</code>标签的<code>node-docker:latest</code>镜像。</p><h2 id="Tag-images"><a href="#Tag-images" class="headerlink" title="Tag images"></a>Tag images</h2><p>镜像名称由斜杠分隔的名称组件组成。名称组件可能包含小写字母、数字和分隔符。分隔符定义为一个句号、一个或两个下划线或一个或多个破折号。名称组件不能以分隔符开始或结束。</p><p>镜像由清单和层列表组成。简单来说，“标签”指向这些工件的组合。一张镜像可以有多个标签。让我们为创建的镜像创建第二个标签，并查看它的图层。</p><p>要为上面构建的图像创建一个新标记，运行以下命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag node-docker:latest node-docker:v1.0.0<br></code></pre></td></tr></table></figure><p><code>Docker tag</code>命令为图像创建一个新标签。它不会创建新的映像。标记指向相同的图像，只是引用图像的另一种方式。</p><p>现在运行<code>docker images</code>命令查看本地映像列表。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>node-docker         latest              3809733582bc        24 minutes ago      945MB<br>node-docker         v1.0.0              3809733582bc        24 minutes ago      945MB<br></code></pre></td></tr></table></figure><p>您可以看到，我们有两个以<code>node-docker</code>开头的镜像。我们知道它们是相同的镜像，因为如果您查看<code>IMAGE ID</code>列，您可以看到两张图像的值是相同的。</p><p>让我们删除刚才创建的标记。为此，我们将使用<code>rmi</code>命令。<code>rmi</code>命令代表<code>remove image</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker rmi node-docker:v1.0.0<br>Untagged: node-docker:v1.0.0<br></code></pre></td></tr></table></figure><p>请注意，Docker的响应告诉我们镜像没有被删除，而只是<code>Untagged</code>。通过运行images命令来验证这一点。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>node-docker         latest              3809733582bc        32 minutes ago      945MB<br></code></pre></td></tr></table></figure><p>标记为<code>v1.0.0</code>的镜像已被删除，但我们的机器上仍然有<code>node-docker:latest</code>标记可用。</p><h1 id="将镜像作为容器运行"><a href="#将镜像作为容器运行" class="headerlink" title="将镜像作为容器运行"></a>将镜像作为容器运行</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>容器是一个正常的操作系统进程，只不过这个进程是隔离的，它有自己的文件系统、自己的网络和自己与主机隔离的进程树。</p><p>要在容器中运行映像，我们使用docker run命令。docker run命令需要一个参数，即映像名称。让我们启动映像并确保它正确运行。在终端中执行以下命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run node-docker<br></code></pre></td></tr></table></figure><p>运行此命令时，您将注意到没有返回到命令提示符。这是因为我们的应用程序是一个REST服务器，它将在一个循环中运行，等待传入的请求，而不将控制返回给操作系统，直到我们停止容器。</p><p>让我们打开一个新终端，然后使用curl命令向服务器发出POST请求。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl --request POST \<br>  --url http://localhost:8000/test \<br>  --header <span class="hljs-string">&#x27;content-type: application/json&#x27;</span> \<br>  --data <span class="hljs-string">&#x27;&#123;&quot;msg&quot;: &quot;testing&quot;&#125;&#x27;</span><br>curl: (7) Failed to connect to localhost port 8000: Connection refused<br></code></pre></td></tr></table></figure><p>我们的curl命令失败了，因为到服务器的连接被拒绝了。这意味着我们无法在端口8000上连接到本地主机。这是意料之中的，因为我们的容器是独立运行的，其中包括网络。让我们停止容器并重新启动在本地网络上发布的端口8000。</p><p>要停止容器，请按ctrl-c。这将返回到终端提示符。</p><p>要为我们的容器发布端口，我们将在docker run命令上使用<code>--publish</code>（简称<code>-p</code>）。<code>--publish</code>的格式是<code>[主机端口]：[容器端口]</code>(<code>[host port]:[container port]</code>)。因此，如果我们想将容器内部的端口8000暴露给容器外部的端口3000，我们将把3000:8000传递给<code>--publish</code>标志。</p><p>启动容器，将8000端口暴露到主机的8000端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --publish 8000:8000 node-docker<br></code></pre></td></tr></table></figure><p>现在让我们从上面重新运行curl命令。记得打开一个新终端。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl --request POST \<br>  --url http://localhost:8000/test \<br>  --header <span class="hljs-string">&#x27;content-type: application/json&#x27;</span> \<br>  --data <span class="hljs-string">&#x27;&#123;&quot;msg&quot;: &quot;testing&quot;&#125;&#x27;</span><br>&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-string">&quot;payload&quot;</span>:[&#123;<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-string">&quot;testing&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;dc0e2c2b-793d-433c-8645-b3a553ea26de&quot;</span>,<span class="hljs-string">&quot;createDate&quot;</span>:<span class="hljs-string">&quot;2020-09-01T17:36:09.897Z&quot;</span>&#125;]&#125;<br></code></pre></td></tr></table></figure><p>成功!我们能够在端口8000上连接到容器中运行的应用程序。切换回运行容器的终端，您应该看到POST请求被记录到控制台。<br><code>2020-09-01T17:36:09:8770 INFO: POST /test</code><br>按ctrl-c停止容器。</p><h2 id="Run-in-detached-mode-以分离模式运行"><a href="#Run-in-detached-mode-以分离模式运行" class="headerlink" title="Run in detached mode(以分离模式运行)"></a>Run in detached mode(以分离模式运行)</h2><p>到目前为止，这是很棒的，但我们的示例应用程序是一个web服务器，我们不应该让我们的终端连接到容器。Docker可以以分离模式或在后台运行容器。为此，我们可以使用<code>--detach</code>或简称为<code>-d</code>。Docker将像以前一样启动你的容器，但这一次将从容器中<code>分离(detached)</code>，并将你返回到终端提示符。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -p 8000:8000 node-docker<br>ce02b3179f0f10085db9edfccd731101868f58631bdf918ca490ff6fd223a93b<br></code></pre></td></tr></table></figure><p>Docker在后台启动容器，并在终端上打印容器ID。</p><p>同样，让我们确保容器正常运行。从上面运行相同的curl命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl --request POST \<br>  --url http://localhost:8000/test \<br>  --header <span class="hljs-string">&#x27;content-type: application/json&#x27;</span> \<br>  --data <span class="hljs-string">&#x27;&#123;&quot;msg&quot;: &quot;testing&quot;&#125;&#x27;</span><br>&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-string">&quot;payload&quot;</span>:[&#123;<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-string">&quot;testing&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;dc0e2c2b-793d-433c-8645-b3a553ea26de&quot;</span>,<span class="hljs-string">&quot;createDate&quot;</span>:<span class="hljs-string">&quot;2020-09-01T17:36:09.897Z&quot;</span>&#125;]&#125;<br></code></pre></td></tr></table></figure><h2 id="List-containers-列出容器"><a href="#List-containers-列出容器" class="headerlink" title="List containers(列出容器)"></a>List containers(列出容器)</h2><p>既然我们在后台运行容器，那么我们如何知道我们的容器是否在运行，或者还有哪些容器在我们的机器上运行呢?好吧，要查看在我们的机器上运行的容器列表，运行<code>docker ps</code>。这类似于在Linux机器上使用ps命令查看进程列表。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES<br>ce02b3179f0f        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   6 minutes ago       Up 6 minutes        0.0.0.0:8000-&gt;8000/tcp   wonderful_kalam<br></code></pre></td></tr></table></figure><p><code>ps</code>命令告诉了我们正在运行的容器的很多信息。我们可以看到容器ID、容器内部运行的映像、用于启动容器的命令、创建容器的时间、状态、暴露的端口和容器的名称。</p><p>您可能想知道容器的名称是从哪里来的。因为我们在启动容器时没有为它提供名称，所以Docker生成了一个随机名称。我们将在一分钟内修复这个问题，但首先我们需要停止容器。要停止容器，请运行<code>docker stop</code>命令，该命令将停止容器。您需要传递容器的名称，也可以使用容器id。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker stop wonderful_kalam<br>wonderful_kalam<br></code></pre></td></tr></table></figure><p>现在重新运行<code>docker ps</code>命令，查看正在运行的容器列表。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker ps<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br></code></pre></td></tr></table></figure><h2 id="Stop-start-and-name-containers-停止，启动，命名容器"><a href="#Stop-start-and-name-containers-停止，启动，命名容器" class="headerlink" title="Stop, start, and name containers(停止，启动，命名容器)"></a>Stop, start, and name containers(停止，启动，命名容器)</h2><p>Docker容器可以启动、停止和重新启动。当我们停止一个容器时，它并没有被移除，而是状态被改变为<code>stopped</code>，容器内的进程也停止了。当我们运行<code>docker ps</code>命令时，默认输出是只显示正在运行的容器。如果传递<code>--all</code>或简称<code>-a</code>，我们将看到系统上的所有容器，无论它们是停止还是启动。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker ps -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES<br>ce02b3179f0f        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   16 minutes ago      Exited (0) 5 minutes ago                        wonderful_kalam<br>ec45285c456d        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   28 minutes ago      Exited (0) 20 minutes ago                       agitated_moser<br>fb7a41809e5d        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   37 minutes ago      Exited (0) 36 minutes ago                       goofy_khayyam<br></code></pre></td></tr></table></figure><p>如果您一直在跟随本文，应该会看到列出了几个容器。这些是我们启动和停止但没有被移除的容器。</p><p>让我们重新启动刚刚停止的容器。找到我们刚刚停止的容器的名称，并在重启命令中替换下面的容器名称。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker restart wonderful_kalam<br></code></pre></td></tr></table></figure><p>现在，使用<code>ps</code>命令再次列出所有容器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker ps --all<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES<br>ce02b3179f0f        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   19 minutes ago      Up 8 seconds                0.0.0.0:8000-&gt;8000/tcp   wonderful_kalam<br>ec45285c456d        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   31 minutes ago      Exited (0) 23 minutes ago                            agitated_moser<br>fb7a41809e5d        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   40 minutes ago      Exited (0) 39 minutes ago                            goofy_khayyam<br></code></pre></td></tr></table></figure><p>注意，我们刚刚重新启动的容器是以分离模式启动的，并公开了端口8000。另外，观察容器的状态是“Up X秒”。当您重新启动容器时，它将使用与最初启动时相同的标志或命令启动。</p><p>让我们停下来，删除所有的容器，看看如何修复随机命名问题。</p><p>停止我们刚刚启动的容器。找到正在运行的容器的名称，并将下面命令中的名称替换为系统上的容器名称。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker stop wonderful_kalam<br>wonderful_kalam<br></code></pre></td></tr></table></figure><p>现在我们所有的容器都停止了，让我们移除它们。当一个容器被移除时，它不再运行，也不处于停止状态。但是，容器内部的进程已经停止，容器的元信息已经删除。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker ps --all<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES<br>ce02b3179f0f        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   19 minutes ago      Up 8 seconds                0.0.0.0:8000-&gt;8000/tcp   wonderful_kalam<br>ec45285c456d        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   31 minutes ago      Exited (0) 23 minutes ago                            agitated_moser<br>fb7a41809e5d        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   40 minutes ago      Exited (0) 39 minutes ago                            goofy_khayyam<br></code></pre></td></tr></table></figure><p>要删除容器，只需传递容器名称，运行<code>docker rm</code>命令。您可以在一个命令中将多个容器名称传递给该命令。</p><p>同样，请确保将下面命令中的容器名称替换为来自系统的容器名称。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">rm</span> wonderful_kalam agitated_moser goofy_khayyam<br>wonderful_kalam<br>agitated_moser<br>goofy_khayyam<br></code></pre></td></tr></table></figure><p>再次运行<code>docker ps --all</code>命令，查看是否所有容器都消失了。</p><p>现在让我们来解决烦人的随机命名问题。标准做法是为容器命名，原因很简单，这样更容易识别容器中正在运行的内容以及与之关联的应用程序或服务。就像代码中变量的良好命名约定可以使其更易于阅读一样，容器的命名也是如此。</p><p>要命名容器，我们只需要将<code>--name</code>标志传递给<code>run</code>命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -p 8000:8000 --name rest-server node-docker<br>1aa5d46418a68705c81782a58456a4ccdb56a309cb5e6bd399478d01eaa5cdda<br>docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES<br>1aa5d46418a6        node-docker         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   3 seconds ago       Up 3 seconds        0.0.0.0:8000-&gt;8000/tcp   rest-server<br></code></pre></td></tr></table></figure><p>现在，我们可以根据名称轻松识别容器。</p><h1 id="使用容器进行开发"><a href="#使用容器进行开发" class="headerlink" title="使用容器进行开发"></a>使用容器进行开发</h1><h2 id="本地数据库和容器"><a href="#本地数据库和容器" class="headerlink" title="本地数据库和容器"></a>本地数据库和容器</h2><p>首先，我们将了解如何在容器中运行数据库，以及如何使用卷和网络来持久化数据，并允许应用程序与数据库进行通信。然后，我们将把所有内容整合到一个组合文件中，该文件将允许我们使用一个命令来设置和运行本地开发环境。最后，我们将看看如何将调试器连接到运行在容器中的应用程序。</p><p>我们可以使用MongoDB的Docker官方镜像，并在容器中运行MongoDB，而不是下载MongoDB，安装，配置，然后将MongoDB数据库作为服务运行。</p><p>在容器中运行MongoDB之前，我们想要创建几个卷，Docker可以管理这些卷来存储我们的持久数据和配置。让我们使用docker提供的托管卷特性，而不是使用绑定挂载。有关更多信息，请参见<a href="https://docs.docker.com/storage/volumes/">使用卷</a>。</p><p>现在让我们创建卷。我们将创建一个用于数据，另一个用于MongoDB的配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume create mongodb<br>docker volume create mongodb_config<br></code></pre></td></tr></table></figure><p>现在，我们将创建一个网络，应用程序和数据库将使用该网络相互通信。该网络称为用户定义的网桥网络，并为我们提供了一个很好的DNS查找服务，我们可以在创建连接字符串时使用该服务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker network create mongodb<br></code></pre></td></tr></table></figure><p>现在我们可以在容器中运行MongoDB，并连接到上面创建的卷和网络。Docker将从Hub中提取镜像并在本地为您运行它。</p><h1 id="启动一个不退出的容器"><a href="#启动一个不退出的容器" class="headerlink" title="启动一个不退出的容器"></a>启动一个不退出的容器</h1><p>可以使用<code>-dit</code>命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -dit --name node16Container node:16<br></code></pre></td></tr></table></figure><ul><li>-d 参数告诉 Docker 在后台运行容器。</li><li>-i 参数表示要求 Docker 将标准输入（stdin）保持打开状态。</li><li>-t 参数表示要求 Docker 为容器分配一个伪终端（pseudo-TTY），以便用户可以与容器进行交互。(可以去掉)</li><li>–name node16Container 参数指定新创建的容器的名称为 node16Container。</li><li>node:16 是要运行的镜像名称和标签。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 iTerm2 打造美观高效的 Mac 终端</title>
      <link href="/2023/03/14/iTerm2/"/>
      <url>/2023/03/14/iTerm2/</url>
      
        <content type="html"><![CDATA[<h1 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h1><p><a href="https://iterm2.com/">iTerm2</a> 是默认终端的替代品，也是目前 macOS 下最好用的终端工具，集颜值和效率于一身。</p><p>进入官网，点击Download按钮进行下载安装。<br><img src="https://s1.ax1x.com/2023/03/15/pp1yxMD.png" alt="pp1yxMD.png"></p><h1 id="进行一些基础设置"><a href="#进行一些基础设置" class="headerlink" title="进行一些基础设置"></a>进行一些基础设置</h1><h2 id="设置热键"><a href="#设置热键" class="headerlink" title="设置热键"></a>设置热键</h2><p>为了快速唤出 iterm2 终端，这里推荐使用热键进行唤出。但是需要程序常驻后台，也就是说不能退出程序，这就好比你使用微信截图或者QQ截图功能，需要打开对应的程序。<br><img src="https://s1.ax1x.com/2023/03/15/pp16CdA.png" alt="pp16CdA.png"><br><img src="https://s1.ax1x.com/2023/03/15/pp16Mon.png" alt="pp16Mon.png"><br><img src="https://s1.ax1x.com/2023/03/15/pp16uZj.png" alt="pp16uZj.png"></p><h2 id="设置status-bar（顶部的状态栏）"><a href="#设置status-bar（顶部的状态栏）" class="headerlink" title="设置status bar（顶部的状态栏）"></a>设置status bar（顶部的状态栏）</h2><p>iterm2 提供了很多 Status bar，可在在终端页面显示更多关于本机的信息，如：CPU、内存、电池电量等。<br><img src="https://s1.ax1x.com/2023/03/15/pp16Kds.png" alt="pp16Kds.png"><br><img src="https://s1.ax1x.com/2023/03/15/pp16mLQ.png" alt="pp16mLQ.png"></p><h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><p>选择一个自己喜欢的配色方案或者自定义。<br><img src="https://s1.ax1x.com/2023/03/15/pp16liq.png" alt="pp16liq.png"></p><h2 id="光标选择"><a href="#光标选择" class="headerlink" title="光标选择"></a>光标选择</h2><p>这里提供了三种光标可供选择：<code>_</code>,<code>|</code>,<code>[]</code><br><img src="https://s1.ax1x.com/2023/03/15/pp163WV.png" alt="pp163WV.png"></p><h2 id="窗口设置"><a href="#窗口设置" class="headerlink" title="窗口设置"></a>窗口设置</h2><p>这里可以设置窗口透明度、背景图片、行列数以及风格等。<br>可参考：<br>![pp16qmQ.png](<a href="https://s1.ax1x.com/2023/03/15/pp16qmQ.png">https://s1.ax1x.com/2023/03/15/pp16qmQ.png</a></p><mark class="hl-label green">最终效果如下</mark> <p><img src="https://s1.ax1x.com/2023/03/15/pp16HOg.png" alt="pp16HOg.png"></p><h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://ohmyz.sh/">oh-my-zsh</a>可能需要科学上网工具才能进行访问</p><div class="tabs" id="one"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#one-1">使用crul</button></li><li class="tab"><button type="button" data-href="#one-2">使用wegt</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="one-1"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="one-2"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>这里暂且先不做配置，使用oh my zsh的默认主题，如有需要可自行上网搜索</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="zsh-autosuggestiongit"><a href="#zsh-autosuggestiongit" class="headerlink" title="zsh-autosuggestiongit"></a>zsh-autosuggestiongit</h2><blockquote><p><code>zsh-autosuggestion</code>是<code>oh-my-zsh</code>的一个插件，作用基本上是根据历史输入指令的记录即时的提示，能够很大的提高效率。</p></blockquote><h2 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h2><blockquote><p><code>zsh-syntax-highlighting</code>是一个语法高亮插件</p></blockquote><h2 id="安装并配置"><a href="#安装并配置" class="headerlink" title="安装并配置"></a>安装并配置</h2><ol><li>来到zsh的插件目录<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-variable">$ZSH_CUSTOM</span>/plugins<br></code></pre></td></tr></table></figure></li><li>下载自动补全插件<code>zsh-autosuggestions</code>和 高亮插件<code>zsh-syntax-highlighting</code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git<br></code></pre></td></tr></table></figure></li><li>使用vim打开oh-my-zsh的配置文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi ~/.zshrc<br></code></pre></td></tr></table></figure>在配置文件.zshrc中找到以下配置，在git后面（换行）添加下载的插件名称，可能需要多找一下，因为这个位置在文件的较下面,如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">plugins=(<br>    git<br>    zsh-autosuggestions <br>    zsh-syntax-highlighting<br>)<br></code></pre></td></tr></table></figure></li><li>刷新配置文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure></li></ol><mark class="hl-label green">成功</mark> ]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之JS基础篇(三)</title>
      <link href="/2023/02/20/JavaScript/interview-js03/"/>
      <url>/2023/02/20/JavaScript/interview-js03/</url>
      
        <content type="html"><![CDATA[<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>在 JavaScript 中，赋值操作符<code>=</code>可以实现浅拷贝，即复制一个对象的引用给另一个对象。当修改其中一个对象的属性时，另一个对象的相应属性也会改变。这是因为两个对象共享同一个内存地址。</p><p>但是，在某些情况下，我们需要拷贝一个对象，同时又不想改变原始对象，这时就需要深拷贝了。深拷贝是指将一个对象完整地拷贝一份，即创建一个新的对象，两个对象互不影响。</p><p>实现深拷贝有多种方法，其中比较常见的是：</p><ol><li>JSON.parse() 和 JSON.stringify() 实现<br>这种方法先将对象序列化为 JSON 字符串，再将字符串解析为新的对象，从而实现深拷贝。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));<br>&#125;<br></code></pre></td></tr></table></figure>这种方法虽然简单，但是有一些<mark class="hl-label red">限制</mark> ：</li></ol><ul><li>无法处理函数、正则表达式、Date 等特殊类型。</li><li>无法处理循环引用的情况，比如对象 A 的某个属性引用了对象 A 本身。</li></ul><ol start="2"><li>手动递归拷贝每个属性<br>递归实现是最常见的深拷贝方法，通过递归遍历对象或数组，将其内部的对象或数组也递归拷贝。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-comment">// 判断是否是对象或数组</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br><br>  <span class="hljs-comment">// 判断对象的类型是数组还是对象</span><br>  <span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br><br>  <span class="hljs-comment">// 递归拷贝对象或数组内部的元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    newObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Object.assign() 实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br>&#125;<br></code></pre></td></tr></table></figure>这种方法也存在一些<mark class="hl-label red">限制</mark> ，同样无法处理函数、正则表达式、Date 等特殊类型，并且只能拷贝对象的可枚举属性。</li></ol><h1 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h1><p>防抖和节流是优化JavaScript性能的两种常用技巧。</p><p>防抖指的是在一段时间内，如果同一个函数被多次触发，只执行最后一次触发的函数。适用于如input搜索框输入时，用户频繁输入的情况，可以在用户输入停止一段时间后再去请求数据，减少请求次数。</p><mark class="hl-label green">实现防抖</mark> 需要使用定时器和函数绑定。每次触发事件时，清除之前的定时器，然后重新设置定时器。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    timerId = <span class="hljs-built_in">setTimeout</span>(fn, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流指的是一段时间内，不管同一个函数被触发了多少次，只执行一次函数。适用于如滚动条滚动时，每隔一段时间才执行函数，减少函数调用次数。</p><mark class="hl-label green">实现节流</mark> 也需要使用定时器和函数绑定。每次触发事件时，判断上一次触发时间和当前时间是否超过规定的时间间隔，如果是则执行函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123;<br>      <span class="hljs-title function_">fn</span>();<br>      lastTime = now;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，防抖和节流的实现方式是不同的，具体使用哪一种取决于具体的业务场景。</p><h1 id="typeof类型判断"><a href="#typeof类型判断" class="headerlink" title="typeof类型判断"></a>typeof类型判断</h1><p>JavaScript中的typeof运算符用于判断一个变量的数据类型。它可以返回以下几种类型的字符串值：</p><ol><li><code>undefined</code>：表示该变量未定义或未初始化。</li><li><code>boolean</code>：表示该变量是一个布尔值类型。</li><li><code>number</code>：表示该变量是一个数字类型。</li><li><code>bigint</code>: 表示该变量是一个任意精度格式的整数。</li><li><code>string</code>：表示该变量是一个字符串类型。</li><li><code>symbol</code>: 表示该变量是唯一的。</li><li><code>object</code>：表示该变量是一个对象类型，但不包括null,<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null">原因</a>。</li><li><code>function</code>：表示该变量是一个函数类型。</li></ol><blockquote><p>以下是一些示例：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;; <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">42n</span>; <span class="hljs-comment">// &quot;bigint&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;test&#x27;</span>); <span class="hljs-comment">// &quot;symbol&quot;</span><br></code></pre></td></tr></table></figure><div class="note info flat"><p>需要注意的是，typeof对于null返回的是”object”。这是一个历史遗留问题，因为在JavaScript早期版本中，null被认为是一个空对象的引用。此外，typeof也无法区分不同的对象类型，例如数组和对象都会返回”object”。</p></div><h1 id="Event-Loop执行机制过程"><a href="#Event-Loop执行机制过程" class="headerlink" title="Event Loop执行机制过程"></a>Event Loop执行机制过程</h1><p>Event Loop是JavaScript运行时的一种机制，用于协调处理事件、执行回调函数、管理异步任务等。其主要作用是维护一个执行栈和一个任务队列，每当执行栈为空时，就会从任务队列中取出一个任务并执行。</p><p>具体的执行过程可以分为以下几个阶段：</p><ol><li><p>执行同步任务：JavaScript引擎执行代码时，先从全局上下文中的执行栈中取出一个同步任务开始执行。如果执行栈中有多个同步任务，则按照入栈的顺序依次执行。</p></li><li><p>执行微任务：当同步任务执行完毕后，JavaScript引擎会立即处理微任务队列中的任务，按照入队顺序依次执行。常见的微任务有<code>Promise</code>、<code>MutationObserver</code>、<code>process.nextTick</code>等。</p></li><li><p>执行宏任务：当微任务队列中的任务全部执行完毕后，JavaScript引擎会从宏任务队列中取出一个任务进行执行。常见的宏任务有<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>requestAnimationFrame</code>等。</p></li><li><p>更新渲染：如果当前宏任务是浏览器的渲染任务，则会执行渲染操作，更新页面显示。此时，如果有新的微任务产生，则会立即执行它们，直到微任务队列为空。</p></li><li><p>等待新任务：当当前宏任务执行完毕后，JavaScript引擎会等待新的任务进入宏任务队列，然后开始新的一轮事件循环。</p></li></ol><p>需要注意的是，<mark class="hl-label red">微任务具有高优先级</mark> ，每次只会执行一个微任务，直到微任务队列为空。而宏任务则不同，每次执行一个宏任务之前，都会检查一次微任务队列，并执行其中的所有任务。这也就是为什么微任务能够在宏任务之前执行的原因。</p><p>另外，需要注意的是，在JavaScript中存在两个任务队列，分别是宏任务队列和微任务队列。宏任务队列中的任务是由<strong>浏览器API</strong>产生的，而微任务队列中的任务则是<strong>由JavaScript代码产生</strong>的。因此，微任务的执行速度要比宏任务快，而且可以保证宏任务之前执行完毕。</p><h1 id="常见排序算法及其复杂度"><a href="#常见排序算法及其复杂度" class="headerlink" title="常见排序算法及其复杂度"></a>常见排序算法及其复杂度</h1><table><thead><tr><th align="center">算法</th><th align="center">平均时间复杂度</th><th align="center">最坏时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">插入排序</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(n log n)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(n log n)</td><td align="center">O(n^2)</td><td align="center">O(log n)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(n + k)</td><td align="center">O(n + k)</td><td align="center">O(k)</td><td align="center">稳定</td></tr><tr><td align="center">桶排序</td><td align="center">O(n + k)</td><td align="center">O(n^2)</td><td align="center">O(n + k)</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(n * k)</td><td align="center">O(n * k)</td><td align="center">O(n + k)</td><td align="center">稳定</td></tr></tbody></table><div class="note info flat"><p>其中，n 表示数据量大小，k 表示数据范围大小。从表格中可以看出，每种算法的时间复杂度和空间复杂度各有优劣，具体使用哪种算法取决于排序数据的特点和要求。</p></div>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之JS基础篇(二)</title>
      <link href="/2023/02/17/JavaScript/interview-js02/"/>
      <url>/2023/02/17/JavaScript/interview-js02/</url>
      
        <content type="html"><![CDATA[<h1 id="null，undefined的区别"><a href="#null，undefined的区别" class="headerlink" title="null，undefined的区别"></a>null，undefined的区别</h1><p>在 JavaScript 中，<code>null</code>和<code>undefined</code>都表示“没有值”的含义，但在使用时有一些区别。</p><p><code>null</code>表示一个空对象指针，即该处不应该有值，是开发者为变量赋值的一种“无值”的情况。<code>undefined</code>表示变量已经声明，但是并未赋值，或者被显式地赋值为<code>undefined</code>。在使用<code>null</code>和<code>undefined</code>时需要注意：</p><ul><li>如果要检查变量是否为<code>null</code>或<code>undefined</code>，最好使用全等运算符（&#x3D;&#x3D;&#x3D; 或 !&#x3D;&#x3D;），因为这两个值都是 falsy 值（即转换为布尔值时为 false），使用双等运算符（&#x3D;&#x3D; 或 !&#x3D;）可能会出现意外结果。</li><li>如果要判断一个变量是否为<code>null</code>，可以使用<code>null</code>字面量进行判断，如：<code>myVar === null</code>。</li><li>如果要判断一个变量是否为<code>undefined</code>，可以使用 typeof 运算符，如：<code>typeof myVar === &#39;undefined&#39;</code>。</li><li>在声明变量时，尽量不要将变量初始化为<code>undefined</code>，因为<code>undefined</code>不是 JavaScript 中保留字，可能会被重定义为其他值，导致无法正常使用。</li></ul><h1 id="“1”-”2”-”3”-map-parseint-答案是多少"><a href="#“1”-”2”-”3”-map-parseint-答案是多少" class="headerlink" title="[“1”,”2”,”3”].map(parseint),答案是多少"></a>[“1”,”2”,”3”].map(parseint),答案是多少</h1><p><strong>结果是 [1, NaN, NaN]</strong><br>这是因为<code>Array.map</code>会将每个元素传入回调函数中，回调函数的第一个参数是当前元素，第二个参数是当前元素的索引。而<code>parseInt</code>函数接受两个参数：要转换的值和进制数，其中第二个参数是进制数。由于<code>parseInt</code>函数没有明确指定进制时，它会将第二个参数视为默认的进制数，如果该参数不是一个有效的数字，则返回<code>NaN</code>。</p><p>因此，在这个例子中，调用过程如下：</p><ol><li><code>parseInt(&quot;1&quot;, 0) </code>返回 1，因为进制数为 0 时，按照 10 进制解析。</li><li><code>parseInt(&quot;2&quot;, 1)</code> 返回<code>NaN</code>，因为进制数为 1 时，无法解析。</li><li><code>parseInt(&quot;3&quot;, 2)</code> 返回<code>NaN</code>，因为在 2 进制下，数字中包含了 3。</li></ol><h1 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h1><p>渐进增强和优雅降级都是Web开发中的设计理念，主要是为了提高应用的可用性和适应性。它们的主要区别在于实现的方向不同。</p><p>渐进增强是指首先基于最基本的设备和浏览器功能进行开发，然后逐渐添加更高级别的功能，以保证应用在不同的浏览器和设备上都能够正确地工作。这种方法强调从简单到复杂的逐步开发过程，以确保最大程度地提高应用程序的兼容性和可用性。</p><p>优雅降级是指首先基于最先进的设备和浏览器功能进行开发，然后逐渐降低功能水平以适应较低级别的设备和浏览器。这种方法强调在不影响高端用户体验的前提下，尽可能地在所有浏览器和设备上提供相似的体验。</p><p>渐进增强和优雅降级的实现都需要兼顾应用程序的兼容性和用户体验，但两者的思想不同，选择哪一种取决于应用程序的目标和要求。</p><h1 id="说说JS严格模式的限制"><a href="#说说JS严格模式的限制" class="headerlink" title="说说JS严格模式的限制"></a>说说JS严格模式的限制</h1><p>JS严格模式是一种JS执行模式，它可以让JS语法限制更加严格，从而避免一些常见的JS错误，提高代码的可靠性。以下是JS严格模式的一些限制：</p><ol><li>变量必须先声明后使用：在严格模式下，不声明直接使用变量会抛出错误。</li><li>不能使用未声明的变量：在严格模式下，使用未声明的变量会抛出错误。</li><li>函数必须声明在顶层：在严格模式下，不允许在非函数代码块中声明函数。</li><li>函数参数不能有同名属性：在严格模式下，函数的参数中不允许出现同名属性。</li><li>禁止使用with语句：在严格模式下，不允许使用with语句，因为with语句会改变作用域链。</li><li>eval函数具有自己的作用域：在严格模式下，eval函数的作用域与所在的作用域是隔离的。</li><li>禁止删除变量：在严格模式下，不允许使用delete操作符删除变量。</li><li>对象不能有重名属性：在严格模式下，不允许在一个对象中定义多个重名的属性。</li><li>arguments对象的限制：在严格模式下，arguments对象的行为发生了一些改变，比如不能修改arguments的值，也不能定义同名参数和arguments对象。</li></ol><p>这些限制可以帮助开发者避免一些常见的JS错误，提高代码的可靠性。</p><h1 id="attribute和property的区别是什么"><a href="#attribute和property的区别是什么" class="headerlink" title="attribute和property的区别是什么"></a>attribute和property的区别是什么</h1><p>在 HTML 中，每个元素都有属性和对应的 DOM 对象属性。这两者之间存在着差异，需要理解属性和 DOM 属性之间的区别。</p><p>属性指的是 HTML 元素在 HTML 代码中声明的属性，是一个字符串类型的值，而 DOM 属性指的是对应的 DOM 对象上的属性，是 JavaScript 对象类型的值。也就是说，属性是元素的特征，而 DOM 对象是元素的接口，JavaScript 通过它来操作 HTML 元素。</p><p>在 JavaScript 中，通过元素的 property 访问元素的 DOM 属性，例如<code>element.id</code>。而通过元素的 attribute 访问元素的 HTML 属性，例如<code>element.getAttribute(&#39;id&#39;)</code>。一些属性和属性名称会有所不同，例如<code>class</code>在 HTML 中是一个属性，但在 JavaScript 中是一个保留关键字，因此要写成<code>className</code>。另一个例子是<code>for</code>，在 JavaScript 中要写成<code>htmlFor</code>。</p><p>这两者之间的差异主要体现在它们的用途和操作方式上。HTML 属性是静态的，一旦被设置就不能再次更改。而 DOM 属性是动态的，可以在运行时修改。此外，属性和 DOM 属性的值有时候会不同，例如<code>input</code>元素的<code>value</code>属性，它在 HTML 中可以设置为一个默认值，但是在 DOM 中它代表的是当前输入框中的值。</p><h1 id="谈谈你对ES6的理解"><a href="#谈谈你对ES6的理解" class="headerlink" title="谈谈你对ES6的理解"></a>谈谈你对ES6的理解</h1><p>ES6（ECMAScript 2015）是 JavaScript 的一个标准版本，是 JavaScript 历史上最重要的一次更新，引入了许多新的语法和功能。</p><p>以下是我对 ES6 的一些理解：</p><ol><li>let 和 const 关键字：let 和 const 可以用来定义块级作用域的变量和常量，避免了使用 var 时因为变量提升导致的作用域问题。</li><li>模板字符串：模板字符串可以使用反引号来定义，可以包含变量、表达式和换行符等，比传统的字符串拼接更加简洁易读。</li><li>箭头函数：箭头函数是一种更加简洁的函数定义方式，可以省略 function 关键字和大括号，还可以自动绑定 this。</li><li>默认参数：可以为函数的参数指定默认值，调用函数时可以省略这些参数，使得函数调用更加简洁。</li><li>解构赋值：解构赋值可以从数组或对象中提取值并赋给变量，减少了手动赋值的代码量，使得代码更加简洁。</li><li>扩展运算符：扩展运算符可以将数组或对象展开成单个元素，或者将单个元素合并成数组或对象。</li><li>Promise：Promise 是一种更加优雅的异步编程方式，避免了回调地狱的问题。</li><li>Class 和模块化：ES6 引入了类的概念，可以更加方便地进行面向对象编程，同时也引入了模块化的概念，可以更加方便地组织代码。</li><li>迭代器和生成器：迭代器和生成器可以用来实现可迭代对象和惰性计算，更加方便地处理数据。</li></ol><p>这些只是 ES6 的一些重要特性，还有许多其他的新功能，ES6 的出现使得 JavaScript 编程变得更加简单、灵活和强大。</p><h1 id="ECMAScript-6-怎么写class"><a href="#ECMAScript-6-怎么写class" class="headerlink" title="ECMAScript 6,怎么写class"></a>ECMAScript 6,怎么写class</h1><p>在ECMAScript 6中，我们可以使用<code>class</code>关键字来定义类。一个简单的类声明可以像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-comment">// 类的构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;MyClass&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 类的方法</span><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello from <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>!`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个名为<code>MyClass</code>的类，它有一个构造函数和一个<code>sayHello</code>方法。我们可以用<code>new</code>关键字来创建这个类的实例，并调用它的<code>sayHello</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>myClass.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello from MyClass!</span><br></code></pre></td></tr></table></figure><p>在类中，我们可以使用<code>constructor</code>方法来初始化对象的属性。类中定义的方法会被添加到对象的原型中，所以它们可以在类的所有实例中共享。</p><p>除了<code>constructor</code>方法，ES6还为我们提供了一些其他的语法糖来简化类的定义，例如<code>extends</code>关键字用于继承父类，<code>super</code>关键字用于调用父类的方法等。</p><h1 id="面向对象编程思想"><a href="#面向对象编程思想" class="headerlink" title="面向对象编程思想"></a>面向对象编程思想</h1><p>面向对象编程（Object-Oriented Programming，OOP）是一种程序设计思想，它是一种基于“对象”的概念，将数据和操作数据的行为封装在一起，以便更好地组织和管理代码。OOP 的核心是封装、继承和多态。</p><p>在 OOP 中，一个对象是一个实例，包含了可以访问和操作的数据和方法。类是用于创建对象的模板，它定义了一组属性和方法，描述了一类对象的行为和特征。类中的属性和方法可以被对象实例访问和使用。继承是指子类继承父类的属性和方法，可以通过扩展父类来创建新的子类。多态是指同一个操作作用于不同的对象上时，可以产生不同的结果，这种机制可以大大提高代码的灵活性和可维护性。</p><div class="note green no-icon flat"><p>面向对象编程的优点包括：</p></div><ol><li><p>代码复用性高，可以封装通用的方法和属性，降低重复代码的出现。</p></li><li><p>代码可维护性高，由于属性和方法已经被封装，修改其中的一个属性或方法不会对其他属性或方法产生影响，使得代码易于维护。</p></li><li><p>可扩展性高，通过继承和多态等机制，可以非常方便地扩展和修改代码功能。</p></li><li><p>代码的抽象程度高，可以将复杂的业务逻辑抽象为一个类，方便代码的理解和维护。</p></li><li><p>代码的可读性高，由于面向对象编程可以将一个复杂的问题分解为多个简单的问题，使得代码更加易于理解。</p></li></ol><div class="note red no-icon flat"><p>但是面向对象编程也有其缺点，包括：</p></div><ol><li><p>学习成本高，需要掌握一定的编程思想和语法，对初学者来说有一定的难度。</p></li><li><p>性能问题，由于面向对象编程中涉及到封装、继承和多态等机制，可能会带来一定的性能问题。</p></li><li><p>过度设计，由于面向对象编程中可以定义大量的类和方法，可能会导致过度设计，增加代码的复杂度和维护难度。</p></li></ol><p>总的来说，面向对象编程是一种非常重要的编程思想，它在软件开发中有着广泛的应用。</p><h1 id="JS中，0-1-0-2为什么不等于0-3？如何让其相等"><a href="#JS中，0-1-0-2为什么不等于0-3？如何让其相等" class="headerlink" title="JS中，0.1+0.2为什么不等于0.3？如何让其相等"></a>JS中，0.1+0.2为什么不等于0.3？如何让其相等</h1><p>在JavaScript中，0.1 + 0.2 不等于 0.3 的原因是由于浮点数的存储和精度问题。因为在计算机内部，数字被表示成二进制形式，有些数字用二进制形式表示时是无限循环小数，而计算机只能存储有限的位数，因此会出现精度问题。</p><p>要让它们相等，可以使用一些方法：</p><ol><li>使用toFixed() 方法来保留两位小数，并将其转换为字符串。然后再将这两个字符串转换为数字并相加，就可以得到正确的结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = (<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// &quot;0.3&quot;</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Number</span>(sum); <span class="hljs-comment">// 0.3</span><br></code></pre></td></tr></table></figure></li><li>将两个数相加后与一个很小的数进行比较，例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<br><span class="hljs-keyword">let</span> result = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(sum - <span class="hljs-number">0.3</span>) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><div class="note green no-icon flat"><p>使用Number.EPSILON可以确保你比较的值很小，即使浮点数的精度变得非常高，也不会出现错误。</p></div></li></ol><h1 id="对web标准、可用性、可访问性的理解"><a href="#对web标准、可用性、可访问性的理解" class="headerlink" title="对web标准、可用性、可访问性的理解"></a>对web标准、可用性、可访问性的理解</h1><p>Web标准是指由W3C等标准化组织所定义的Web技术规范，它们包括HTML、CSS、JavaScript等。遵循Web标准可以让Web页面具有更好的兼容性、可维护性和可扩展性，同时也能提升Web页面的性能。</p><p>可用性是指用户能够轻松地使用一个产品或系统，并能在其它用户中发挥相同的效果。对于Web页面来说，良好的可用性意味着页面内容易于理解和使用，操作方式直观和简单，用户能够快速地完成任务。</p><p>可访问性是指Web页面应该对所有用户开放，包括那些具有视觉、听觉、运动和认知方面的障碍的用户。Web页面应该提供多种方式来呈现内容，如文本、图像、视频、音频等，并且应该提供一些辅助功能，如放大缩小、语音朗读等，以使得用户能够方便地获取和理解内容。</p><h1 id="谈一谈let与var的区别"><a href="#谈一谈let与var的区别" class="headerlink" title="谈一谈let与var的区别"></a>谈一谈let与var的区别</h1><p>在 JavaScript 中，let 和 var 是两种常见的声明变量的方式，二者虽然很相似，但还是有一些区别的：</p><ol><li><p>作用域：var 声明的变量的作用域是函数作用域或全局作用域，而 let 声明的变量的作用域是块级作用域（比如 if 语句、for 循环等代码块）。</p></li><li><p>变量提升：var 声明的变量存在变量提升现象，即变量可以在声明之前被使用，而 let 声明的变量不存在变量提升，必须先声明再使用，否则会报错。</p></li><li><p>重复声明：在同一个作用域中，var 可以重复声明同一个变量，而 let 不行，否则会报错。</p></li><li><p>全局声明：在全局作用域中使用 var 声明的变量会成为全局对象（window）的属性，而 let 不会。</p></li></ol><p>因此，建议在 ES6 之后使用 let 来声明变量，因为它更加安全、可控，可以避免许多潜在的问题。但是在一些老的浏览器中可能不支持 let 关键字，因此在实际开发中需要权衡利弊，根据实际情况选择使用 var 还是 let。</p><h1 id="谈一谈你理解的函数式编程"><a href="#谈一谈你理解的函数式编程" class="headerlink" title="谈一谈你理解的函数式编程"></a>谈一谈你理解的函数式编程</h1><p>函数式编程（Functional Programming）是一种编程范式，将计算视为数学函数的运算，在函数式编程中，函数被视为一等公民，可以像变量一样进行传递、赋值和使用，函数式编程强调函数的纯粹性，即函数不应该改变外部环境或者产生副作用，每次调用相同的函数参数，都应该得到相同的结果。</p><p>函数式编程通常使用纯函数（Pure Function）来实现。纯函数是指对于同样的输入，总是能得到同样的输出，且不会产生副作用。在函数式编程中，尽可能地使用纯函数来进行编程，可以提高程序的可读性、可维护性和测试性，同时也能够更好地支持并发和分布式计算。</p><p>在函数式编程中，常用的操作包括映射（map）、过滤（filter）、折叠（reduce）等。这些操作可以组合在一起形成复杂的操作，可以使用柯里化（Currying）将函数转化为接收一个参数的函数序列，也可以使用高阶函数（Higher-Order Function）将函数作为参数或返回值进行传递。</p><p>JavaScript作为一门支持函数式编程的语言，提供了很多支持函数式编程的语言特性，比如箭头函数、函数绑定、解构赋值、展开运算符、柯里化等。这些特性使得使用JavaScript进行函数式编程变得更加方便和灵活。</p><h1 id="谈一谈箭头函数与普通函数的区别"><a href="#谈一谈箭头函数与普通函数的区别" class="headerlink" title="谈一谈箭头函数与普通函数的区别"></a>谈一谈箭头函数与普通函数的区别</h1><p>箭头函数是ES6中新增的一种函数定义方式，相比于普通函数，有以下区别</p><ol><li>箭头函数没有自己的this对象，它的this指向的是定义时所在的作用域中的this。这意味着在箭头函数中，无法通过this访问到全局对象或者调用者对象，可以避免this指向错误的问题。</li><li>箭头函数不能作为构造函数使用，因为它没有自己的this对象，也没有prototype属性。</li><li>箭头函数不能使用arguments对象，但是可以使用剩余参数(rest parameters)。</li><li>箭头函数没有自己的arguments对象，它的arguments指向的是定义时所在的作用域中的arguments。</li></ol><p>另外，与普通函数相比，箭头函数更加简洁，可以省略函数体中的return语句，同时也可以省略函数体的花括号，只需要在函数体中写一个表达式即可。</p><h1 id="谈一谈函数中this的指向"><a href="#谈一谈函数中this的指向" class="headerlink" title="谈一谈函数中this的指向"></a>谈一谈函数中this的指向</h1><p>在 JavaScript 中，函数中的<code>this</code>关键字指的是当前函数执行时所属的对象。这个对象可以是任何一个对象，而<code>this</code>的值取决于函数的调用方式。在函数中，有以下几种情况：</p><ol><li><p>在普通函数中，<code>this</code>默认指向全局对象<code>window</code>，但在严格模式下，<code>this</code>会是<code>undefined</code>。</p></li><li><p>在对象方法中，<code>this</code>指向调用该方法的对象。</p></li><li><p>在构造函数中，<code>this</code>指向正在创建的对象。</p></li><li><p>在事件处理函数中，<code>this</code>指向触发事件的对象。</p></li><li><p>使用<code>call()</code>或<code>apply()</code>方法调用函数时，可以手动指定<code>this</code>的值。</p></li><li><p>箭头函数中的<code>this</code>不会随着执行上下文的变化而改变，而是根据词法作用域进行绑定，指向函数定义时所处的上下文。</p></li></ol><p>因此，在使用函数时，需要考虑 this 的指向，以免出现意料之外的问题。</p><h1 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="headerlink" title="异步编程的实现方式"></a>异步编程的实现方式</h1><p>异步编程是指程序的执行过程中，可以在某些操作需要等待的时候，先去执行其他操作，等到需要的操作完成后再去执行后续的代码。在 JavaScript 中，常见的异步编程实现方式有以下几种：</p><ol><li><p>回调函数：在函数调用的时候，传入一个回调函数作为参数，当操作完成时，调用该回调函数执行后续操作。</p></li><li><p>Promise：Promise 对象表示一个异步操作的最终完成（或失败），提供了链式调用的语法，可以避免回调函数嵌套过深的问题。</p></li><li><p>Async&#x2F;await：ES7 引入了 async&#x2F;await 关键字，用于异步编程，可以使用类似同步代码的语法来编写异步代码，避免回调函数嵌套和 Promise 链式调用的问题。</p></li><li><p>事件驱动：使用事件监听的方式来处理异步操作，比如 Node.js 中的 EventEmitter 类，浏览器中的 DOM 事件监听。</p></li><li><p>发布&#x2F;订阅：发布&#x2F;订阅模式也是一种异步编程实现方式，不同于事件驱动，它没有明确的事件类型，订阅者只需订阅消息，而发布者只需发布消息，两者不需要直接交互。</p></li></ol><p>不同的实现方式有各自的优缺点，选择适合场景的实现方式可以使代码更易于维护和扩展。</p><h1 id="对原生javascript了解程度"><a href="#对原生javascript了解程度" class="headerlink" title="对原生javascript了解程度"></a>对原生javascript了解程度</h1><p>作为一个语言，JavaScript 非常灵活和强大，但同时也具有复杂性和不确定性。作为一个前端开发者，我认为对原生 JavaScript 的掌握是非常重要的。在我的工作中，我经常使用原生 JavaScript 来解决一些特定的问题，比如<code>操作DOM</code>、<code>事件处理</code>、<code>AJAX 调用</code>、<code>动画效果</code>、<code>表单验证</code>等。我熟悉原生JavaScript的<code>数据类型</code>、<code>函数</code>、<code>作用域</code>、<code>闭包</code>、<code>原型链</code>、<code>异步编程</code>等方面的知识，并且能够灵活地应用这些知识来完成特定的任务。在我的日常工作中，我也会经常查阅文档和阅读相关的书籍和博客来加深对 JavaScript 的理解和应用。</p><h1 id="js动画与css动画区别及相应实现"><a href="#js动画与css动画区别及相应实现" class="headerlink" title="js动画与css动画区别及相应实现"></a>js动画与css动画区别及相应实现</h1><p>JavaScript动画和CSS动画都可以用来创建动态效果，但它们的实现方式和使用场景有所不同。</p><p>CSS动画是通过CSS属性过渡或变化来实现动画效果的。CSS动画通常更适合实现简单的动画效果，如悬停状态、按钮点击效果等。CSS动画使用起来比较简单，不需要编写太多代码，而且可以直接使用浏览器的硬件加速来提高性能。但是，CSS动画的可定制性和复杂性相对较差，难以实现复杂的动态效果。</p><p>JavaScript动画是通过编写JavaScript代码来实现动画效果的。JavaScript动画通常更适合实现复杂的动画效果，如物体的移动、旋转、缩放等。JavaScript动画需要编写较多的代码，但它的可定制性和灵活性更好，可以实现更复杂的动态效果。JavaScript动画也可以利用浏览器的硬件加速来提高性能，但需要谨慎使用以避免影响页面性能。</p><p>在实际开发中，可以根据需要来选择使用CSS动画或JavaScript动画，也可以将它们结合起来使用，以实现更丰富、更复杂的动态效果。</p><h1 id="数组和对象的遍历方式，以及几种方式的比较"><a href="#数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="数组和对象的遍历方式，以及几种方式的比较"></a>数组和对象的遍历方式，以及几种方式的比较</h1><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ol><li>for循环<br>使用 for 循环是最常见的遍历数组的方式，通过下标逐个访问数组元素。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>forEach<br>forEach 是一个数组的迭代方法，能够依次迭代数组中的每个元素。forEach 方法需要一个回调函数，该函数接收数组中的每个元素、该元素在数组中的索引以及整个数组作为参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value, index, array</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>for…of<br>for…of 是 ES6 新增的遍历数组的语法，它可以直接遍历数组中的元素而无需使用下标，而且可以避免数组元素的变量提升问题。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><ol><li>for…in<br>for…in 语句用于遍历对象的可枚举属性，它可以枚举对象自身的属性，还可以枚举从原型链上继承的属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;: &quot;</span> + obj[key]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Object.keys()<br>Object.keys() 方法返回一个由对象的可枚举属性名组成的数组，可以遍历对象自身的属性，但不能遍历原型链上的属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;: &quot;</span> + obj[key]);<br>&#125;);<br></code></pre></td></tr></table></figure><div class="note info no-icon flat"><p>比较：</p><ol><li>for 循环可以遍历数组和对象，但需要使用下标或属性名访问元素，不够直观；</li><li>forEach 用于遍历数组，代码简洁，但无法在中途跳出循环；</li><li>for…of 只能用于遍历数组，可以直接访问元素，代码简洁，但不能遍历对象；</li><li>for…in 可以遍历对象的可枚举属性，包括自身的和继承的属性，但不能遍历数组；</li><li>Object.keys() 可以遍历对象自身的可枚举属性，返回一个数组，使用数组方法对其进行操作较为方便。</li></ol></div></li></ol><h1 id="Gulp是什么"><a href="#Gulp是什么" class="headerlink" title="Gulp是什么"></a>Gulp是什么</h1><p><a href="https://www.gulpjs.com.cn/">Gulp</a>是一款基于Node.js的前端自动化构建工具，用于自动化处理 JavaScript、CSS、HTML、图片等文件的构建、压缩、编译、打包等一系列重复的任务。Gulp使用简单，可读性高，扩展性强，能够让前端工程师更加高效地完成前端工作。Gulp的核心思想是通过管道（stream）来传输数据，使得前端开发人员可以方便地将多个任务串联起来，形成自己的构建流程。</p><h1 id="说一下vue2的双向绑定数据的原理"><a href="#说一下vue2的双向绑定数据的原理" class="headerlink" title="说一下vue2的双向绑定数据的原理"></a>说一下vue2的双向绑定数据的原理</h1><p>在 Vue2 中，双向绑定是通过数据劫持实现的。具体来说，Vue 通过使用<code>Object.defineProperty()</code>方法来劫持组件中每个属性的<code>getter</code>和<code>setter</code>方法，从而实现数据的双向绑定。</p><p>当 Vue 将组件中的 data 对象传入 Vue 实例中时，Vue 会对这个 data 对象进行遍历，为每个属性设置<code>getter</code>和<code>setter</code>方法。当 data 中的属性被访问时，会触发<code>getter</code>方法，当属性值被修改时，会触发<code>setter</code>方法。在<code>setter </code>方法中，Vue 会通知所依赖的组件重新渲染，从而实现数据的响应式更新。</p><p>在模板中，使用<code>v-model</code>指令可以实现双向绑定。<code>v-model</code>实际上是一个语法糖，它会根据组件绑定的表单元素的类型自动使用不同的属性和事件实现双向绑定。比如，对于<code>input</code>元素，<code>v-model</code>会使用<code>value</code>属性和<code>input</code>事件，对于<code>textarea</code>元素，<code>v-model</code>会使用<code>value</code>属性和<code>input</code>事件。</p><p>总之，Vue2 中的双向绑定数据的原理是通过数据劫持实现的，通过<code>Object.defineProperty()</code>方法来劫持组件中每个属性的<code>getter</code>和<code>setter</code>方法，并使用<code>v-model</code>指令实现在模板中的双向绑定。</p><h1 id="浏览器事件的各个阶段"><a href="#浏览器事件的各个阶段" class="headerlink" title="浏览器事件的各个阶段"></a>浏览器事件的各个阶段</h1><p>在浏览器中，事件的处理经历了三个阶段：捕获阶段、目标阶段和冒泡阶段。这被称为事件传播（Event Propagation）或事件流（Event Flow）。</p><p>在捕获阶段，事件从根节点一直向下传播，直到达到触发事件的元素。在目标阶段，事件在触发事件的元素上被触发，然后继续传播到下一个阶段。在冒泡阶段，事件从触发事件的元素开始向上冒泡，直到到达根节点。</p><p>在事件的处理过程中，通过<code>addEventListener</code>方法添加的事件处理函数会按照注册的顺序执行，而且默认情况下，事件处理函数会在冒泡阶段被执行。如果需要在捕获阶段执行事件处理函数，可以将<code>addEventListener</code>的第三个参数设置为<code>true</code>。如果需要阻止事件的传播，可以使用<code>stopPropagation</code>方法；如果需要阻止默认的行为，可以使用<code>preventDefault</code>方法。</p><h1 id="快速的让一个数组乱序"><a href="#快速的让一个数组乱序" class="headerlink" title="快速的让一个数组乱序"></a>快速的让一个数组乱序</h1><p>可以使用现代浏览器提供的Array.prototype.sort()方法结合Math.random()函数实现数组乱序。具体实现可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们调用了数组的sort方法，然后传入一个回调函数作为参数，该回调函数返回一个随机值（0 到 1 之间）与 0.5 的差值。由于sort方法的内部机制，这将导致数组中的元素被随机排序。最后我们输出乱序后的数组。</p><h1 id="如何渲染几万条数据并不卡住界面"><a href="#如何渲染几万条数据并不卡住界面" class="headerlink" title="如何渲染几万条数据并不卡住界面"></a>如何渲染几万条数据并不卡住界面</h1><p>在渲染大量数据时，通常会出现界面卡顿的问题，为了避免这种情况，我们可以采用以下方法：</p><ol><li><p>分页显示：将数据分页显示，每次只显示一部分数据，减少一次性渲染的压力。</p></li><li><p>虚拟滚动：只渲染当前可视区域的数据，当滚动条滚动时，动态地更新当前显示的数据，这样就能够保持高性能的同时，又能够呈现出全部的数据。</p></li><li><p>使用 React 的 shouldComponentUpdate 方法：React 的 shouldComponentUpdate 方法可以用来控制组件是否需要重新渲染，通过避免不必要的渲染，可以提高性能。</p></li><li><p>使用 Web Worker：将数据的处理操作交给 Web Worker 来执行，可以减轻主线程的负担，提高渲染的效率。</p></li><li><p>使用缓存：如果数据不经常变化，可以将其缓存起来，避免重复渲染。</p></li><li><p>使用 requestAnimationFrame：requestAnimationFrame 方法能够在浏览器下一次重绘之前执行回调函数，可以避免阻塞渲染线程，提高性能。</p></li><li><p>使用 CSS3 动画：CSS3 动画可以使用 GPU 加速，避免阻塞主线程，提高性能。</p></li></ol><p>总之，要实现高性能的数据渲染，需要结合具体的情况，采用不同的优化方法，才能达到最好的效果。</p><h1 id="希望获取到页面中所有的checkbox怎么做"><a href="#希望获取到页面中所有的checkbox怎么做" class="headerlink" title="希望获取到页面中所有的checkbox怎么做"></a>希望获取到页面中所有的checkbox怎么做</h1><p>要获取页面中所有的checkbox，可以使用以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> checkboxes = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;input[type=&quot;checkbox&quot;]&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这个代码使用了<code>querySelectorAll</code>方法来获取所有类型为<code>checkbox</code>的<code>&lt;input&gt;</code>元素，并将它们存储在一个变量中。可以使用这个变量来遍历所有的<code>checkbox</code>，或者执行其他的操作。</p><h1 id="怎样添加、移除、移动、复制、创建和查找节点"><a href="#怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="怎样添加、移除、移动、复制、创建和查找节点"></a>怎样添加、移除、移动、复制、创建和查找节点</h1><p>操作DOM树（Document Object Model）是Web开发中经常使用的操作之一，以下是常见的操作节点的方法：</p><ol><li>添加节点</li></ol><ul><li>createElement(tagName)：创建一个元素节点</li><li>createTextNode(text)：创建一个文本节点</li><li>parentNode.appendChild(node)：将node节点添加到parentNode的最后一个子节点</li><li>parentNode.insertBefore(newNode, existingNode)：将newNode节点插入到existingNode节点之前</li></ul><ol start="2"><li>移除节点</li></ol><ul><li>parentNode.removeChild(node)：移除parentNode节点的子节点node</li></ul><ol start="3"><li>移动节点</li></ol><ul><li>parentNode.insertBefore(node, existingNode)：将node节点插入到existingNode节点之前，从而实现移动节点的效果</li></ul><ol start="4"><li>复制节点</li></ol><ul><li>node.cloneNode(boolean)：复制一个节点，其中boolean表示是否复制子节点</li><li>parentNode.insertBefore(node.cloneNode(true), existingNode)：将一个复制节点插入到existingNode节点之前</li></ul><ol start="5"><li>创建节点</li></ol><ul><li>createElement(tagName)：创建一个元素节点</li><li>createTextNode(text)：创建一个文本节点</li></ul><ol start="6"><li>查找节点</li></ol><ul><li>document.getElementById(id)：通过元素id查找元素节点</li><li>parentNode.getElementsByTagName(tagName)：在parentNode节点下查找tagName标签的所有元素节点</li><li>parentNode.getElementsByClassName(className)：在parentNode节点下查找className类名的所有元素节点</li><li>parentNode.querySelector(selector)：在parentNode节点下查找匹配选择器selector的第一个元素节点</li><li>parentNode.querySelectorAll(selector)：在parentNode节点下查找匹配选择器selector的所有元素节点</li></ul><p>以上是常见的操作DOM树的方法，可以根据需要选择使用。</p><h1 id="window-onload和-document-ready"><a href="#window-onload和-document-ready" class="headerlink" title="window.onload和$(document).ready()"></a>window.onload和$(document).ready()</h1><p><code>window.onload</code>和<code>$(document).ready()</code>都是用于在页面加载完成后执行 JavaScript 代码的事件。不过它们的执行时机有所不同。</p><ul><li><code>window.onload</code>是等到页面及页面内所有资源（如图片）全部加载完成后再执行。这意味着如果页面上有大量资源需要加载，那么<code>window.onload</code>事件会比较晚触发，会影响网页的加载速度和用户体验。</li><li><code>$(document).ready()</code>是 jQuery 提供的一个事件，在 DOM 树构建完成后立即执行。也就是说，页面上的 HTML、CSS 和 JS 资源已经加载完成，但是图片等其他资源可能还没有加载完。这样能够保证在页面加载完成后尽早地执行 JavaScript，从而加快页面渲染速度。</li></ul><p>因此，一般建议使用<code>$(document).ready()</code>来执行 JavaScript 代码，而不是<code>window.onload</code>。除非特殊需要在页面内所有资源加载完成后才能执行的情况下才使用<code>window.onload</code>。</p><h1 id="addeventlistener和attachevent的区别"><a href="#addeventlistener和attachevent的区别" class="headerlink" title="addeventlistener和attachevent的区别"></a>addeventlistener和attachevent的区别</h1><p><code>addEventListener</code>和<code>attachEvent</code>都是用于在元素上添加事件监听器的方法，它们的主要区别在于以下几点：</p><ol><li><p>浏览器兼容性：<code>addEventListener</code>是标准的DOM方法，适用于现代浏览器和IE9及以上版本；而<code>attachEvent</code>是IE特有的方法，只适用于IE8及以下版本。</p></li><li><p>事件处理器执行顺序：当一个元素上添加多个相同类型的事件处理器时，<code>addEventListener</code>会按照添加的顺序依次执行，而<code>attachEvent</code>会以相反的顺序执行。</p></li><li><p>事件处理器作用域：<code>addEventListener</code>的事件处理器函数默认在当前元素的作用域中执行，而<code>attachEvent</code>的事件处理器函数在全局作用域中执行，因此在处理器中使用this关键字的含义不同。</p></li><li><p>事件名称：在IE8及以下版本中，某些事件名称与标准不一致，例如<code>attachEvent</code>的<code>onbeforeunload</code>事件名称是不带前缀“on”的。</p></li></ol><h1 id="数组去重方法总结"><a href="#数组去重方法总结" class="headerlink" title="数组去重方法总结"></a>数组去重方法总结</h1><p>在 JavaScript 中，有多种方法可以对数组进行去重操作。以下是一些常见的数组去重方法：</p><ol><li>使用Set<br>可以使用 ES6 中引入的 Set 数据结构，将数组转换为 Set，再将 Set 转回数组。由于 Set 不允许重复值存在，这样可以达到去重的目的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> uniqueArr = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li>使用 indexOf<br>可以使用 indexOf 方法遍历数组，检查当前元素是否已经在数组中存在，如果不存在则加入到新数组中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> uniqueArr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (uniqueArr.<span class="hljs-title function_">indexOf</span>(arr[i]) === -<span class="hljs-number">1</span>) &#123;<br>    uniqueArr.<span class="hljs-title function_">push</span>(arr[i]);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li>使用 includes<br>可以使用 includes 方法遍历数组，检查当前元素是否已经在数组中存在，如果不存在则加入到新数组中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> uniqueArr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (!uniqueArr.<span class="hljs-title function_">includes</span>(arr[i])) &#123;<br>    uniqueArr.<span class="hljs-title function_">push</span>(arr[i]);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li>使用 filter<br>可以使用 filter 方法遍历数组，返回一个新数组，新数组中包含原数组中所有不重复的元素。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> uniqueArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> arr.<span class="hljs-title function_">indexOf</span>(item) === index);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li></ol><div class="note info flat"><p>需要注意的是，使用 indexOf 和 includes 方法进行数组去重的效率相对较低，而使用 Set 和 filter 方法则更为高效。</p></div><h1 id="设计题-想实现一个对页面某个节点的拖曳-如何做-使用原生js"><a href="#设计题-想实现一个对页面某个节点的拖曳-如何做-使用原生js" class="headerlink" title="设计题,想实现一个对页面某个节点的拖曳,如何做?使用原生js"></a>设计题,想实现一个对页面某个节点的拖曳,如何做?使用原生js</h1><p>实现对页面某个节点的拖拽可以分为以下几个步骤：</p><ol><li>给需要拖拽的节点绑定mousedown、mousemove、mouseup事件。</li><li>在mousedown事件中记录鼠标当前位置和被拖拽元素的位置。</li><li>在mousemove事件中计算被拖拽元素应该移动的距离，并更新被拖拽元素的位置。</li><li>在mouseup事件中移除mousemove和mouseup事件</li></ol><p>下面是一个实现示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drag&quot;</span>&gt;</span>可以拖拽的元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#drag</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">cursor</span>: grab;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> drag = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;drag&#x27;</span>);<br><span class="hljs-keyword">var</span> mouseX, mouseY, eleX, eleY, isDrag = <span class="hljs-literal">false</span>;<br><br>drag.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    drag.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">&#x27;grabbing&#x27;</span>;<br>    <span class="hljs-comment">// 记录鼠标当前位置和被拖拽元素的位置</span><br>    mouseX = event.<span class="hljs-property">clientX</span>;<br>    mouseY = event.<span class="hljs-property">clientY</span>;<br>    eleX = <span class="hljs-built_in">parseInt</span>(drag.<span class="hljs-property">style</span>.<span class="hljs-property">left</span>) || <span class="hljs-number">0</span>;<br>    eleY = <span class="hljs-built_in">parseInt</span>(drag.<span class="hljs-property">style</span>.<span class="hljs-property">top</span>) || <span class="hljs-number">0</span>;<br>    isDrag = <span class="hljs-literal">true</span>;<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (isDrag) &#123;<br>        <span class="hljs-comment">// 计算被拖拽元素应该移动的距离，并更新被拖拽元素的位置</span><br>        <span class="hljs-keyword">var</span> deltaX = event.<span class="hljs-property">clientX</span> - mouseX;<br>        <span class="hljs-keyword">var</span> deltaY = event.<span class="hljs-property">clientY</span> - mouseY;<br>        drag.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = eleX + deltaX + <span class="hljs-string">&#x27;px&#x27;</span>;<br>        drag.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = eleY + deltaY + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 移除mousemove和mouseup事件</span><br>    isDrag = <span class="hljs-literal">false</span>;<br>    drag.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">&#x27;grab&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在该示例中，首先获取了需要拖拽的元素drag，并给它绑定了mousedown事件。在mousedown事件中记录了鼠标当前位置和被拖拽元素的位置，并将isDrag标志设置为true。</p><p>接下来，在document上绑定了mousemove事件，在事件中检查isDrag标志，如果为true，则计算被拖拽元素应该移动的距离，并更新被拖拽元素的位置。</p><p>最后，在document上绑定了mouseup事件，在事件中将isDrag标志设置为false，从而停止拖拽。</p><p>需要注意的是，在mousemove和mouseup事件中，需要判断isDrag标志，以避免在未按下鼠标时也触发拖拽事件。</p><h1 id="使用js实现一个持续的动画效果"><a href="#使用js实现一个持续的动画效果" class="headerlink" title="使用js实现一个持续的动画效果"></a>使用js实现一个持续的动画效果</h1><p>要实现一个持续的动画效果，可以使用 requestAnimationFrame 方法来更新动画的状态，使其在每一帧都发生变化，从而实现动画效果。</p><p>以下是一个简单的示例，展示如何使用 requestAnimationFrame 方法实现一个持续的旋转动画：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;box&#x27;</span>);<br><span class="hljs-keyword">var</span> angle = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params"></span>) &#123;<br>    angle += <span class="hljs-number">2</span>;<br>    box.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;rotate(&#x27;</span> + angle + <span class="hljs-string">&#x27;deg)&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (angle &gt;= <span class="hljs-number">360</span>) &#123;<br>        angle = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(rotate);<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(rotate);<br></code></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个 rotate 函数来更新 box 元素的旋转角度，并在每一帧使用 requestAnimationFrame 方法来调用该函数，从而实现持续的动画效果。</p><p>为了避免angle的值会随着时间的变化越来越大，当旋转一圈时，也就是360°，其实可以重置为0。</p><h1 id="封装一个函数，参数是定时器的时间，then执行回调函数"><a href="#封装一个函数，参数是定时器的时间，then执行回调函数" class="headerlink" title="封装一个函数，参数是定时器的时间，then执行回调函数"></a>封装一个函数，参数是定时器的时间，then执行回调函数</h1><p>可以封装一个函数，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">time, callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(callback, time);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>time</code>参数表示定时器的时间，单位为毫秒；<code>callback</code>参数表示定时器执行的回调函数。</p><p>使用时，可以这样调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;一秒后执行&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述代码表示，延迟1秒后执行一个回调函数，该函数在控制台输出一段文字。</p><h1 id="怎么判断两个对象相等"><a href="#怎么判断两个对象相等" class="headerlink" title="怎么判断两个对象相等"></a>怎么判断两个对象相等</h1><p>在 JavaScript 中，对象相等的判断通常分为两种：</p><ol><li>浅相等：两个对象只有当它们引用同一个对象时才相等；</li><li>深相等：两个对象在属性和属性值上完全相等时才相等。</li></ol><p>判断浅相等可以使用<code>===</code>运算符，判断深相等可以使用循环递归或第三方库。下面给出一个使用循环递归判断深相等的示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObjectEqual</span>(<span class="hljs-params">obj1, obj2</span>) &#123;<br>  <span class="hljs-comment">// 如果两个对象引用同一个对象，则相等</span><br>  <span class="hljs-keyword">if</span> (obj1 === obj2) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 判断两个对象属性的数量是否相等</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj1).<span class="hljs-property">length</span> !== <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj2).<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 递归判断两个对象属性的值是否相等</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj1) &#123;<br>    <span class="hljs-keyword">if</span> (obj1.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">if</span> (!obj2.<span class="hljs-title function_">hasOwnProperty</span>(key) || !<span class="hljs-title function_">isObjectEqual</span>(obj1[key], obj2[key])) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用示例：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> obj3 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125; &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isObjectEqual</span>(obj1, obj2)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isObjectEqual</span>(obj1, obj3)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之CSS基础篇(三)</title>
      <link href="/2023/02/16/Css/interview-css03/"/>
      <url>/2023/02/16/Css/interview-css03/</url>
      
        <content type="html"><![CDATA[<h1 id="a标签上四个伪类的执行顺序是怎么样的"><a href="#a标签上四个伪类的执行顺序是怎么样的" class="headerlink" title="a标签上四个伪类的执行顺序是怎么样的"></a>a标签上四个伪类的执行顺序是怎么样的</h1><p><code>a</code>标签上的四个伪类是<code>:link</code>、<code>:visited</code>、<code>:hover</code>、<code>:active</code>。它们的执行顺序是：</p><ol><li><p><code>:link</code>，表示链接的初始状态，未访问的链接。</p></li><li><p><code>:visited</code>，表示链接被访问过的状态。</p></li><li><p><code>:hover</code>，表示鼠标悬停在链接上的状态。</p></li><li><p><code>:active</code>，表示链接被激活的状态，即鼠标按下但还没有释放的状态。</p></li></ol><p>其中<code>:visited</code>会受到安全策略的影响，不允许修改链接的颜色、背景颜色和边框颜色等属性，以防止恶意网站进行欺骗、钓鱼等活动。<br>如果有多个伪类选择器同时作用于一个元素，那么它们的优先级与 CSS 选择器的优先级规则一样，即后面的选择器优先级高。</p><blockquote><p>例如，对于以下样式：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: green;&#125;<br></code></pre></td></tr></table></figure><p>当鼠标悬停在链接上时，文字颜色将变成<mark class="hl-label green">绿色</mark> ，而不是红色。</p><h1 id="网站图片文件，如何点击下载，而非点击预览"><a href="#网站图片文件，如何点击下载，而非点击预览" class="headerlink" title="网站图片文件，如何点击下载，而非点击预览"></a>网站图片文件，如何点击下载，而非点击预览</h1><p>要让网站上的图片文件以下载而不是预览的形式呈现，可以为图片文件添加下载属性（download attribute）。</p><p>在 HTML 中，可以通过在<code>&lt;a&gt;</code>标签中使用 download 属性来实现图片的下载。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;path/to/image.jpg&quot;</span> <span class="hljs-attr">download</span>&gt;</span>Download Image<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的代码会创建一个链接，点击链接会自动下载 path&#x2F;to&#x2F;image.jpg 文件，而不是在浏览器中打开它。其中 download 属性告诉浏览器该链接是要下载文件的链接，而不是用来导航到另一个页面的链接。</p><div class="note info flat"><p>另外，需要注意的是，download 属性不是所有浏览器都支持的。如果用户使用的浏览器不支持该属性，那么链接仍然会打开文件而不是下载它。</p></div><h1 id="iOS-Safari，如何阻止-橡皮筋效果"><a href="#iOS-Safari，如何阻止-橡皮筋效果" class="headerlink" title="iOS Safari，如何阻止-橡皮筋效果"></a>iOS Safari，如何阻止-橡皮筋效果</h1><p>在 iOS 的 Safari 中，橡皮筋效果也被称为“弹性滚动”（Bounce Scrolling）。它是指当用户在页面滚动到顶部或底部时，会出现一种“反弹”的效果，就好像页面撞到了一个弹簧上一样。</p><p>如果你想阻止这种效果，可以通过 CSS 样式或 JavaScript 代码来实现。以下是两种方法：</p><ol><li>CSS 样式<br>使用以下 CSS 样式可以禁用橡皮筋效果：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  overscroll-behavior: none;<br>&#125;<br></code></pre></td></tr></table></figure>该属性可以在 iOS 11+ 的 Safari 中使用，它可以防止页面滚动时的反弹效果。</li><li>JavaScript 代码<br>使用以下 JavaScript 代码可以禁用橡皮筋效果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br></code></pre></td></tr></table></figure>这段代码会在页面上的任何触摸移动事件发生时，阻止默认的滚动行为。注意，<code>&#123; passive: false &#125;</code>参数是必需的，因为默认情况下，<code>touchmove</code>事件是以被动方式处理的，无法通过<code>preventDefault()</code>阻止。<div class="note info flat"><p>需要注意的是，禁用橡皮筋效果可能会对用户体验产生负面影响，因此需要谨慎使用。</p></div></li></ol><h1 id="对line-height的理解"><a href="#对line-height的理解" class="headerlink" title="对line-height的理解"></a>对line-height的理解</h1><p><code>line-height</code>是 CSS 中用来设置文本行间距的属性。它的作用是控制文本行框的高度，从而影响行与行之间的垂直距离。<br><code>line-height</code>可以使用以下三种值之一来设置：</p><ol><li>像素值（px）：直接指定行高为固定像素值。</li><li>百分比值：基于当前文本字体的百分比值。</li><li>无单位值（如 1.5）：基于当前文本字体大小的倍数。</li></ol><p>当<code>line-height</code>的值大于文本字体的大小时，文本将会有额外的垂直间隔，从而形成行间距。如果<code>line-height</code>的值小于文本字体的大小，文本将会被压缩在行框内。</p><p>除了控制文本的行间距，<code>line-height</code>还会影响垂直居中，如通过将<code>line-height</code>设置为与容器高度相同的值可以实现行框内文本的垂直居中。此外，<code>line-height</code>还可以影响行内元素的垂直对齐方式，如通过将<code>line-height</code>设置为相同的值，可以使行内元素垂直居中对齐。</p><h1 id="设置元素浮动后-该元素的display值会如何变化"><a href="#设置元素浮动后-该元素的display值会如何变化" class="headerlink" title="设置元素浮动后,该元素的display值会如何变化?"></a>设置元素浮动后,该元素的display值会如何变化?</h1><mark class="hl-label green">Answer</mark> :不会变化。将一个元素设置为浮动（float）后，该元素的`display`属性不会发生任何变化。它仍然具有先前设置的`display`属性值。<p>浮动（float）是一种布局技术，用于将元素从其正常文档流中移动，并使其在其父容器中左侧或右侧浮动。浮动元素可以与其他元素相邻并环绕在其周围。</p><p>在默认情况下，元素的<code>display</code>属性值通常是<code>block</code>、<code>inline</code>或<code>inline-block</code>。设置元素的<code>float</code>属性值不会更改其<code>display</code>属性值，但是它会导致该元素的外部显示方式发生变化，因为它将浮动到其父容器中的左侧或右侧。</p><h1 id="让页面里的字体变清晰-变细用css怎么做"><a href="#让页面里的字体变清晰-变细用css怎么做" class="headerlink" title="让页面里的字体变清晰,变细用css怎么做?"></a>让页面里的字体变清晰,变细用css怎么做?</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">-webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased<br>-moz-osx-font-smoothing: grayscale<br>text-shadow: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.005</span>)<br>text-rendering: optimizeLegibility<br></code></pre></td></tr></table></figure><h1 id="font-style属性oblique是什么意思"><a href="#font-style属性oblique是什么意思" class="headerlink" title="font-style属性oblique是什么意思"></a>font-style属性<code>oblique</code>是什么意思</h1><p>CSS的<code>font-style</code>属性用于设置字体的风格，取值包括<code>normal</code>（普通字体）、<code>italic</code>（斜体）和<code>oblique</code>（倾斜体）。</p><p><code>oblique</code>表示将字体倾斜，与<code>italic</code>类似，不过它是通过简单的将字体倾斜来实现的，而不是使用专门设计的斜体字形。这也就意味着，如果原本字体并没有专门设计的斜体字形，那么使用<code>oblique</code>将使得字体变得倾斜，但是并不会改变字体本身的样式。</p><p>举个例子，如果一个网页使用了一个没有专门设计斜体字形的字体，那么可以通过<code>font-style: oblique</code>属性将它倾斜，使得它看起来更加倾斜，但是它的样式仍然会与原本一致。而如果使用<code>font-style: italic</code>，那么字体将会变成它的专门设计的斜体字形，样式可能会略微不同。</p><p>总之，<code>oblique</code>可以让字体在不使用专门设计的斜体字形的情况下，实现一种倾斜效果，但这种倾斜效果与<code>italic</code>的斜体样式有所不同。</p><h1 id="一个高度自适应的div-里面有两个div-一个高度100px-希望另一个填满剩下的高度"><a href="#一个高度自适应的div-里面有两个div-一个高度100px-希望另一个填满剩下的高度" class="headerlink" title="一个高度自适应的div,里面有两个div,一个高度100px,希望另一个填满剩下的高度"></a>一个高度自适应的div,里面有两个div,一个高度100px,希望另一个填满剩下的高度</h1><p>可以使用flexbox布局实现这个需求。具体做法是将包含两个子元素的父元素设置为<code>display: flex; flex-direction: column;</code>，使其成为一个垂直方向的flex容器。这样，子元素将按照垂直方向排列。</p><p>然后，将需要填满剩余高度的子元素设置为<code>flex: 1;</code>，这样它将占据剩余的所有可用空间。另一个高度为100px的子元素可以根据具体需求设置其高度值即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">      <span class="hljs-attribute">flex-direction</span>: column;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child1</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child2</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: lightblue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="css的渲染层合成是什么-浏览器如何创建新的渲染层"><a href="#css的渲染层合成是什么-浏览器如何创建新的渲染层" class="headerlink" title="css的渲染层合成是什么,浏览器如何创建新的渲染层?"></a>css的渲染层合成是什么,浏览器如何创建新的渲染层?</h1><p>CSS渲染层合成（Compositing）是指浏览器根据绘制层（Painting Layer）和图层树（Layer Tree）合成最终的渲染结果的过程。在这个过程中，浏览器会将不同的绘制层进行合并、混合、裁剪等操作，最终生成最终的渲染结果。</p><p>浏览器创建新的渲染层通常是由以下几个步骤完成的：</p><ol><li>根据HTML和CSS生成DOM和CSSOM，然后将它们合并成一个渲染树（Render Tree）。</li><li>将渲染树转化为绘制指令（Painting Command），并生成绘制层（Painting Layer）。</li><li>将不同的绘制层合并为一个复合层（Composite Layer），并且将复合层合成到屏幕上。</li></ol><p>在第二步中，浏览器根据渲染树中每个元素的样式（比如背景颜色、边框等）以及位置信息（比如left、top等）来生成绘制指令，并根据绘制指令创建绘制层。绘制层可以理解为一个二维图形的位图，它包含了元素的所有可见内容，但是不包括透明区域。</p><p>在第三步中，浏览器会根据绘制层的一些属性（比如是否需要裁剪、透明度等）将它们合并为一个复合层。复合层是一个包含多个绘制层的容器，它可以在GPU中进行合成，从而提高性能和减少CPU的占用。在合成过程中，浏览器会将复合层上的所有绘制层进行混合、裁剪、缩放等操作，并最终将结果渲染到屏幕上。</p><p>需要注意的是，浏览器创建新的渲染层的过程是非常复杂的，还受到很多其他因素的影响，比如是否开启GPU加速、硬件性能、页面中元素的数量和复杂度等等。因此，在实际的开发中，我们需要对页面的结构和样式进行优化，以提高页面的性能和用户体验。</p><h1 id="offsetwidth、offsetheight、clientwidth、clientheight与scrollwidth、scrollheight的区别"><a href="#offsetwidth、offsetheight、clientwidth、clientheight与scrollwidth、scrollheight的区别" class="headerlink" title="offsetwidth、offsetheight、clientwidth、clientheight与scrollwidth、scrollheight的区别"></a>offsetwidth、offsetheight、clientwidth、clientheight与scrollwidth、scrollheight的区别</h1><p>在 HTML 中，元素的大小有四个方面需要关注，分别是 content、padding、border、margin，其中 content 指的是元素的实际内容大小。而浏览器提供了一些属性来表示元素的大小，包括<code>offsetWidth</code>、<code>offsetHeight</code>、<code>clientWidth</code>、<code>clientHeight</code>、<code>scrollWidth</code>、<code>scrollHeight</code></p><ul><li><p><code>offsetWidth</code>和<code>offsetHeight</code>：表示元素在页面上占用的空间大小，包括内容、内边距和边框，不包括外边距。即元素在屏幕中的实际大小，单位是像素（px）。</p></li><li><p><code>clientWidth</code>和<code>clientHeight</code>：表示元素的可见区域大小，包括内容和内边距，但不包括边框和外边距。即元素的内容区域的大小，不包括滚动条的宽度和高度，单位是像素（px）。</p></li><li><p><code>scrollWidth</code>和<code>scrollHeight</code>：表示元素的滚动大小，包括元素内容的整个大小，无论是否可见，包括内容、内边距和边框，但不包括外边距。即元素的内容的实际大小，包括滚动区域，单位是像素（px）。</p></li></ul><p>需要注意的是，<code>offsetWidth</code>、<code>offsetHeight</code>、<code>clientWidth</code>、<code>clientHeight</code>、<code>scrollWidth</code>、<code>scrollHeight</code>这些属性都是只读属性，不能手动设置元素的大小。同时，这些属性的值会受到 CSS 样式的影响，如元素的 display 属性、box-sizing 属性等，因此在使用这些属性的时候需要注意浏览器的兼容性。</p><h1 id="常见兼容性问题"><a href="#常见兼容性问题" class="headerlink" title="常见兼容性问题"></a>常见兼容性问题</h1><p>在前端开发中，由于浏览器的兼容性问题，可能会出现一些页面显示异常、样式错乱等问题。以下是一些常见的兼容性问题：</p><ol><li>CSS 盒模型：早期 IE 浏览器（6 及以下版本）默认的盒模型与标准盒模型不一致，这导致在计算元素宽度和高度时会出现问题。</li><li>样式兼容性：不同浏览器可能对 CSS 属性解析的方式不同，例如一些 CSS3 的新属性在旧版本浏览器中不支持，这会导致样式显示不一致。</li><li>JavaScript 兼容性：不同浏览器对 JavaScript 语法和 API 的支持程度不同，例如 IE 浏览器在处理 JavaScript 事件方面有一些兼容性问题。</li><li>HTML 元素的兼容性：不同浏览器可能对 HTML 标签的解析方式不同，例如一些 HTML5 的新元素在旧版本浏览器中不支持。</li><li>图片加载：不同浏览器可能对图片加载的方式不同，例如在某些浏览器中，图片的加载会阻塞 JavaScript 代码的执行，导致页面出现卡顿现象。</li></ol><p>以上只是一些常见的兼容性问题，实际上还有很多其他方面的兼容性问题需要考虑。为了避免这些问题的出现，可以使用一些工具或者技术来帮助我们解决兼容性问题，例如使用 CSS Reset 样式库、使用 CSS 预处理器、使用 JavaScript 框架等。</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之CSS基础篇(二)</title>
      <link href="/2023/02/14/Css/interview-css02/"/>
      <url>/2023/02/14/Css/interview-css02/</url>
      
        <content type="html"><![CDATA[<h1 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别?"></a>伪类和伪元素的区别?</h1><p>在CSS中，伪类和伪元素是两个不同的概念。</p><ul><li><strong>伪类（Pseudo-class）</strong>是CSS中的一种选择器，用于选择某些元素的特定状态，例如链接的状态（未访问、已访问、悬停、激活），或者鼠标悬停在元素上时的状态。伪类在选择器后面使用一个冒号（:）来表示,例如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>上面的代码中，:hover是一个伪类，用于选择鼠标悬停在链接上时的状态，并将链接的颜色设置为红色。</li><li><strong>伪元素（Pseudo-element）</strong>是CSS中的另一种选择器，用于向某些元素添加特殊的效果或内容，例如为某些元素添加特定的样式或者在元素的内容前后添加特定的内容。伪元素在选择器后面使用两个冒号（::）来表示,例如:<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;前缀&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>上面的代码中，<code>::before</code>是一个伪元素，用于在段落内容前添加一个”前缀”，并通过<code>content</code>属性指定前缀的内容。<br>总的来说，伪类用于选择某些元素的特定状态，而伪元素用于向某些元素添加特殊的效果或内容。需要注意的是，虽然伪类和伪元素都是在选择器后面使用冒号或双冒号来表示，但它们的作用是不同的，不能混淆使用。</li></ul><h1 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h1><p>自适应布局是指网页的布局能够自动适应不同设备的屏幕大小和分辨率，使得网页在不同设备上都能够展现良好的效果。在实际开发中，我们通常采用一些CSS技术来实现自适应布局，例如：</p><ol><li><p>使用百分比布局：将网页中的各个元素的宽度、高度、内边距和外边距等样式属性设置为相对于父元素的百分比值，使得它们能够根据父元素的大小进行自适应调整。</p></li><li><p>使用CSS媒体查询：通过CSS媒体查询来检测设备的屏幕宽度，然后根据不同的屏幕大小设置不同的样式，使得网页在不同设备上呈现不同的布局效果。</p></li><li><p>使用流式布局：将网页中的各个元素的宽度、高度、内边距和外边距等样式属性设置为相对于视口（浏览器窗口）宽度的百分比值，使得它们能够随着浏览器窗口大小的改变而自适应调整。</p></li><li><p>使用弹性盒模型：通过CSS3中的弹性盒模型来实现自适应布局，可以方便地调整网页中各个元素的排列和布局。</p></li><li><p>使用rem和vw&#x2F;vh单位：rem单位是相对于根元素(html)字体大小的相对单位，vw&#x2F;vh单位是相对于视口宽度或高度的相对单位，它们可以用于实现响应式布局。</p></li></ol><div class="note info flat"><p>需要注意的是，不同的自适应布局方案适用于不同的场景，开发者需要根据实际需求选择合适的方案。同时，自适应布局也需要考虑到用户体验和性能等问题，不能盲目追求布局的自适应性而影响网页的性能和用户体验。</p></div><h1 id="什么是外边距重叠？重叠的结果是什么？"><a href="#什么是外边距重叠？重叠的结果是什么？" class="headerlink" title="什么是外边距重叠？重叠的结果是什么？"></a>什么是外边距重叠？重叠的结果是什么？</h1><p>外边距重叠是指在两个相邻元素的外边距相遇时，它们之间的外边距将合并为一个外边距。这种情况发生在两个垂直方向上相邻的元素中，其中一个元素的顶部外边距和另一个元素的底部外边距相遇。且重叠后的外边距等于其中<mark class="hl-label red">较大</mark> 者。</p><ol><li>内嵌盒子<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">HTML：<br><span class="hljs-comment">&lt;!-- 嵌套 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-comment">/* padding-top: .1px; */</span><br>  <span class="hljs-comment">/* overflow:hidden; */</span><br>  <span class="hljs-comment">/* overflow:auto; */</span><br>&#125;<br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><mark class="hl-label green">解决办法：</mark> </li></ol><ul><li>给外部盒子设置内边距（padding-top：.1px；）即可。</li><li>给下面的盒子设置overflow（ overflow: hidden; 或 overflow: auto; ）即可。</li></ul><ol start="2"><li>相邻盒子<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 相邻 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l_box&quot;</span>&gt;</span>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l_container&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.l_box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-class">.l_container</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-comment">/* position: absolute; */</span><br>    <span class="hljs-comment">/* float: left; */</span><br>    <span class="hljs-comment">/* display:inline-block; */</span><br>&#125;<br></code></pre></td></tr></table></figure><mark class="hl-label green">解决办法：</mark> </li></ol><ul><li>给下面的盒子设置定位（position：absolute；）即可。</li><li>给下面的盒子设置浮动（float：left；）即可。</li><li>将其中任一个盒子设置为行内块元素（dispaly：inline-block；）即可。</li></ul><h1 id="rgba和opacity的透明效果有什么不同"><a href="#rgba和opacity的透明效果有什么不同" class="headerlink" title="rgba和opacity的透明效果有什么不同?"></a>rgba和opacity的透明效果有什么不同?</h1><p><code>opacity</code>属性控制整个元素及其内容的不透明度，取值范围为 0 到 1，其中 0 表示完全透明，1 表示完全不透明。应用<code>opacity</code>属性后，元素的边框、内边距和背景颜色都将受到相同的透明度影响。</p><p>与之不同，<code>rgba()</code>是一种颜色表示法，其中的 a 值用来控制颜色的透明度。它仅仅对该颜色产生透明度的效果，而不会影响元素本身或元素内部其他颜色的透明度。</p><p>因此，如果想要控制整个元素的透明度，应该使用<code>opacity</code>属性。如果只需要让元素内部的某些颜色透明，可以使用<code>rgba()</code>来设置特定颜色的透明度。</p><h1 id="css中可以让文字在垂直和水平方向上重叠的两个属性是什么"><a href="#css中可以让文字在垂直和水平方向上重叠的两个属性是什么" class="headerlink" title="css中可以让文字在垂直和水平方向上重叠的两个属性是什么?"></a>css中可以让文字在垂直和水平方向上重叠的两个属性是什么?</h1><p>CSS 中可以让文字在垂直和水平方向上重叠的两个属性分别是<code>text-align: center</code>和<code>line-height</code>。</p><ul><li><code>text-align: center</code>属性可以让元素内的文本水平居中对齐，适用于单行文本的情况。</li><li><code>line-height</code>属性可以让文本在垂直方向上对齐。当<code>line-height</code>属性值等于元素的高度时，文本将垂直居中对齐，同时也可以使用负值来调整文本的垂直位置。值得注意的是，<code>line-height</code>可以作用于元素内的所有文本，而不仅仅是单行文本。</li></ul><div class="note info flat"><p>在实际开发中，通常需要结合这两个属性来实现文字的水平和垂直居中对齐。例如，可以将文本所在的容器设置为<code>text-align: center</code>，然后在该容器内部的文本元素中设置合适的 <code>line-height</code>，从而实现文字的水平和垂直居中对齐。</p></div><h1 id="如何垂直居中一个浮动元素？如何让绝对定位的div居中"><a href="#如何垂直居中一个浮动元素？如何让绝对定位的div居中" class="headerlink" title="如何垂直居中一个浮动元素？如何让绝对定位的div居中?"></a>如何垂直居中一个浮动元素？如何让绝对定位的div居中?</h1><h2 id="浮动元素居中"><a href="#浮动元素居中" class="headerlink" title="浮动元素居中"></a>浮动元素居中</h2><p>在 CSS 中，浮动元素的布局方式不同于常规流中的元素，因此垂直居中浮动元素的方法也会有所不同。下面介绍几种不同情况的方法来实现垂直居中一个浮动元素：</p><ol><li><strong>已知元素宽高</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 子盒子 */</span><br><span class="hljs-selector-class">.son</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/* 父元素需要相对定位 */</span><br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>; <span class="hljs-comment">/*二分之一的height，width*/</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>未知父元素高宽</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin</span>: auto; <span class="hljs-comment">/* 居中 */</span><br>    <span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/* 父元素需要相对定位 */</span><br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>使用flex布局</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 父盒子 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background-color</span>: pink;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 水平居中 */</span><br>    <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 上下居中 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>使用transform</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="绝对定位居中"><a href="#绝对定位居中" class="headerlink" title="绝对定位居中"></a>绝对定位居中</h2><ol><li><p>将该<code>&lt;div&gt;</code>元素的宽度和高度设置为固定值（如，宽度为 400px，高度为 300px）。</p></li><li><p>将该<code>&lt;div&gt;</code>元素的 left 和 top 属性都设置为 50%。</p></li><li><p>使用<code>transform</code>属性对该<code>&lt;div&gt;</code>元素进行平移，使其左上角处于页面正中心。</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.absolute-div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就可以让绝对定位的 <div> 元素在页面中水平居中和垂直居中了。</p><h1 id="px和em的区别"><a href="#px和em的区别" class="headerlink" title="px和em的区别"></a>px和em的区别</h1><p><code>px</code>和<code>em</code>都是用来表示长度单位的。</p><ul><li><code>px</code>是绝对长度单位，它表示像素，是一个固定的值。在浏览器中，1个像素通常等于屏幕上的1个物理点，但在高分辨率屏幕上（如Retina屏幕），1个像素可能会对应于多个物理点。</li><li><code>em</code>是相对长度单位，它是相对于当前元素的字体大小来计算的。例如，如果当前元素的字体大小为<code>16px</code>，那么<code>1em</code>就等于<code>16px</code>。如果当前元素的字体大小为<code>20px</code>，那么<code>1em</code> 就等于<code>20px</code>。</li><li><code>em</code>的好处是它可以根据当前元素的字体大小来自适应调整，因此比较适合用于排版和布局中。但是，由于<code>em</code>是相对于当前元素的字体大小来计算的，所以它也有一些不足之处，例如：<ul><li>如果父元素的字体大小发生变化，子元素的尺寸也会跟着变化，这可能会对布局造成一定的影响。</li><li><code>em</code>是相对单位，为每个子元素透过「倍数」乘以父元素的px值，如果我们每一层 div 都使用1.2em，最内层就会是16px x 1.2 x 1.2 x 1.2 x 1.2 x 1.2 &#x3D; 39.8px。(浏览器预设字体大小为16px，若无特别指定则会直接继承父元素字体大小)。</li></ul></li></ul><p>总的来说，<code>px</code>和<code>em</code>在不同的场景下都有它们的用途。在排版和布局中，<code>em</code>可能更为方便和灵活，但是在一些需要精确控制尺寸的情况下，<code>px</code>更为合适。</p><h1 id="如何使用css实现硬件加速"><a href="#如何使用css实现硬件加速" class="headerlink" title="如何使用css实现硬件加速"></a>如何使用css实现硬件加速</h1><p>硬件加速可以通过 CSS 中的 transform 和 opacity 属性来实现。当使用这些属性时，浏览器会将元素的渲染放到 GPU 中处理，而不是通过 CPU 来处理，这样可以提高渲染速度和流畅度。</p><ol><li><strong>使用 transform 属性</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.transform</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>在这个代码中，我们将 transform 属性设置为 translateZ(0)。这个属性可以让元素进入 3D 空间，并让浏览器使用 GPU 进行渲染，从而实现硬件加速。</li><li><strong>使用 opacity 属性</strong><ol><li>CSS Opacity 属性本身并不能实现硬件加速，因为它会影响元素的透明度，从而导致整个元素的重绘。不过，可以通过结合使用 CSS Opacity 属性和 CSS 3D Transform，来实现硬件加速，具体步骤如下：</li><li>创建一个新的图层，使用 will-change 或 transform: translateZ(0) 将元素移动到新的图层中。这个操作会触发 GPU 加速。 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.opacity</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: opacity;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 这样就可以使用 opacity 属性来实现透明效果，同时通过 transform 属性将元素移动到新的图层中，从而实现硬件加速。</li></ol></li></ol><h1 id="重绘和回流是什么？如何避免呢？"><a href="#重绘和回流是什么？如何避免呢？" class="headerlink" title="重绘和回流是什么？如何避免呢？"></a>重绘和回流是什么？如何避免呢？</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>重绘</strong>：当页面元素样式改变不影响元素在文档流中的位置时（如<code>background-color</code>，<code>border-color</code>，<code>visibility</code>），浏览器只会将新样式赋予元素并进行重新绘制操作。</li><li><strong>回流</strong>：当渲染树<code>render tree</code>中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变时，浏览器重新渲染部分DOM或全部DOM的过程。<mark class="hl-label red">回流必将引起重绘，而重绘不一定会引起回流。</mark> </li></ul><h2 id="引起回流"><a href="#引起回流" class="headerlink" title="引起回流"></a>引起回流</h2><ol><li><p>页面渲染初始化</p></li><li><p>DOM结构改变，比如删除了某个节点</p></li><li><p>render树变化，比如减少了padding</p></li><li><p>窗口resize</p></li><li><p>最复杂的一种：获取某些属性，引发回流，<br>很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，<br>但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</p><ol><li>offset(Top&#x2F;Left&#x2F;Width&#x2F;Height)</li><li>scroll(Top&#x2F;Left&#x2F;Width&#x2F;Height)</li><li>cilent(Top&#x2F;Left&#x2F;Width&#x2F;Height)</li><li>width,height</li><li>调用了getComputedStyle()或者IE的currentStyle</li></ol></li></ol><blockquote><p>回流一定伴随着重绘，重绘却可以单独出现,所以一般会有一些优化方案，如：</p></blockquote><ul><li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li><li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li><li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><div class="note info flat"><p>注意：改变字体大小会引发回流</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>;<br><br>s.<span class="hljs-property">padding</span> = <span class="hljs-string">&quot;2px&quot;</span>; <span class="hljs-comment">// 回流+重绘</span><br>s.<span class="hljs-property">border</span> = <span class="hljs-string">&quot;1px solid red&quot;</span>; <span class="hljs-comment">// 再一次 回流+重绘</span><br>s.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;blue&quot;</span>; <span class="hljs-comment">// 再一次重绘</span><br>s.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;#ccc&quot;</span>; <span class="hljs-comment">// 再一次 重绘</span><br>s.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&quot;14px&quot;</span>; <span class="hljs-comment">// 再一次 回流+重绘</span><br><span class="hljs-comment">// 添加node，再一次 回流+重绘</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&#x27;abc!&#x27;</span>));<br></code></pre></td></tr></table></figure><h1 id="CSS-hack原理及常用hack"><a href="#CSS-hack原理及常用hack" class="headerlink" title="CSS hack原理及常用hack"></a>CSS hack原理及常用hack</h1><p>CSS hack 是一种用于解决不同浏览器之间兼容性问题的技巧。由于不同浏览器的 CSS 渲染机制不同，导致同一段 CSS 代码在不同浏览器上的显示效果也不同。因此，为了解决这种兼容性问题，可以使用 CSS hack 技巧来实现不同浏览器下的样式设置。</p><p>CSS hack 的原理是利用浏览器的解析顺序不同，设置不同的 CSS 属性值，从而使不同的浏览器只解析自己能够识别的属性值，达到在不同浏览器下显示相同的效果的目的。</p><p>常用的 CSS hack 技巧包括：</p><ol><li>样式条件注释：使用 HTML 的条件注释语法，对不同版本的 IE 浏览器进行特定的样式设置。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--[if IE 6]&gt;</span><br><span class="hljs-comment">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6.css&quot; /&gt;</span><br><span class="hljs-comment">&lt;![endif]--&gt;</span><br></code></pre></td></tr></table></figure></li><li>属性前缀：根据不同浏览器的 CSS 属性前缀，设置不同的样式规则。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">-webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>; <span class="hljs-comment">/* Safari 和 Chrome */</span><br>-moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>; <span class="hljs-comment">/* Firefox */</span><br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>; <span class="hljs-comment">/* 标准属性 */</span><br></code></pre></td></tr></table></figure></li><li>属性后缀：根据不同浏览器的 CSS 属性后缀，设置不同的样式规则。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ccc</span>\<span class="hljs-number">9</span>; <span class="hljs-comment">/* IE8 及以下 */</span><br><span class="hljs-attribute">background</span>: <span class="hljs-number">#f00</span>\<span class="hljs-number">0</span>/; <span class="hljs-comment">/* IE8 及以下 */</span><br></code></pre></td></tr></table></figure></li><li>选择器 hack：根据不同浏览器对 CSS 选择器的支持程度，设置不同的样式规则。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &gt; <span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#element</span> &#123; <span class="hljs-comment">/* 仅 IE6 可见 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#f00</span>;<br>&#125;<br>* &gt; <span class="hljs-selector-tag">html</span> <span class="hljs-selector-id">#element</span> &#123; <span class="hljs-comment">/* 仅 IE7 可见 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#0f0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>IE6 hack：根据 IE6 的 CSS 渲染机制，设置不同的样式规则。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#element</span> &#123;<br>    _color: <span class="hljs-number">#f00</span>; <span class="hljs-comment">/* 仅 IE6 可见 */</span><br>    *<span class="hljs-attribute">color</span>: <span class="hljs-number">#0f0</span>; <span class="hljs-comment">/* 仅 IE7 及以下可见 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#00f</span>; <span class="hljs-comment">/* 标准属性 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>虽然 CSS hack 可以解决浏览器兼容性问题，但是由于 CSS hack 过于依赖于浏览器的解析机制，因此容易造成代码的混乱和难以维护。因此，建议尽可能避免使用 CSS hack 技巧，而是采用更为标准的 CSS 编写方式，确保网页的可读性和可维护性。</p><p>继承属性可以让子元素继承父元素的样式，这样可以减少 CSS 代码量，提高代码的可维护性和可读性。但是需要注意的是，并不是所有的属性都可以继承，而且不同浏览器对继承属性的支持也不完全一致。因此，在编写 CSS 样式时需要谨慎选择继承属性，以确保样式表的兼容性和可维护性。</p><h1 id="css选择符有哪些"><a href="#css选择符有哪些" class="headerlink" title="css选择符有哪些"></a>css选择符有哪些</h1><p>CSS 选择符（Selector）用于选择要应用样式的 HTML 元素。常见的 CSS 选择符包括：</p><ol><li>元素选择器（tag selector）：根据 HTML 元素的标签名来选择元素，如 div、p、h1 等。</li><li>类选择器（class selector）：根据 HTML 元素的 class 属性来选择元素，如 .classname。</li><li>ID 选择器（ID selector）：根据 HTML 元素的 id 属性来选择元素，如 #idname。</li><li>属性选择器（attribute selector）：根据 HTML 元素的属性值来选择元素，如 [type&#x3D;”text”]。</li><li>伪类选择器（pseudo-class selector）：根据 HTML 元素的状态来选择元素，如 :hover、:focus 等。</li><li>伪元素选择器（pseudo-element selector）：用来选择元素的特定部分，如 ::before、::after 等。</li></ol><p><strong>CSS 中还有一些通用选择器，如 * 通配符选择器，以及组合选择器，如 空格、&gt;、+、~ 等。</strong></p><h1 id="css有哪些继承属性"><a href="#css有哪些继承属性" class="headerlink" title="css有哪些继承属性"></a>css有哪些继承属性</h1><p>CSS 有很多继承属性，主要包括以下几类：</p><ol><li>字体相关属性：font-family、font-size、font-style、font-weight、line-height。</li><li>文本相关属性：text-align、text-indent、text-transform、text-shadow、word-spacing。</li><li>颜色相关属性：color、background-color、border-color。</li><li>列表相关属性：list-style-type、list-style-image、list-style-position。</li><li>表格相关属性：border-collapse、border-spacing、caption-side、empty-cells。</li><li>布局相关属性：display、visibility、white-space、vertical-align、text-decoration、float、clear、position、overflow、z-index。</li></ol><div class="note info flat"><p>需要注意的是，并非所有属性都可以继承，如背景图片、定位相关属性等就不支持继承。</p></div><h1 id="css3新增伪类有那些"><a href="#css3新增伪类有那些" class="headerlink" title="css3新增伪类有那些"></a>css3新增伪类有那些</h1><p>CSS3新增了许多伪类，以下是一些常用的CSS3新增伪类：</p><ol><li>:nth-child(n)：匹配其父元素的第n个子元素。</li><li>:nth-last-child(n)：匹配其父元素的倒数第n个子元素。</li><li>:nth-of-type(n)：匹配其父元素下指定类型的第n个子元素。</li><li>:nth-last-of-type(n)：匹配其父元素下指定类型的倒数第n个子元素。</li><li>:first-child：匹配其父元素下的第一个子元素。</li><li>:last-child：匹配其父元素下的最后一个子元素。</li><li>:first-of-type：匹配其父元素下指定类型的第一个子元素。</li><li>:last-of-type：匹配其父元素下指定类型的最后一个子元素。</li><li>:not(selector)：匹配除了指定选择器之外的所有元素。</li><li>:empty：匹配没有子元素的元素。</li></ol><p>这些新增的伪类可以实现更加精细的选择器定位，可以有效地简化HTML结构，提高CSS样式的复用性。</p><h1 id="如何实现小于12px的字体效果"><a href="#如何实现小于12px的字体效果" class="headerlink" title="如何实现小于12px的字体效果"></a>如何实现小于12px的字体效果</h1><p>小于 12px 的字体在一些低分辨率的设备上可能会变得模糊不清，但是在某些设计中可能需要使用小于 12px 的字体。下面介绍几种实现小于 12px 字体效果的方法：</p><ol><li>使用 SVG 图标代替文本：可以将文本内容转换成 SVG 图标，从而避免使用小于 12px 的字体。</li><li>使用 rem 单位：rem 单位是相对于根元素（html）的字体大小而言的，因此可以通过设置根元素的字体大小来控制整个页面的字体大小。例如：在根元素上设置字体大小为 62.5%，然后使用 1.2rem 即可实现 12px 的字体效果。</li><li>使用 transform 缩小字体：使用 transform 属性可以对元素进行缩放，因此可以使用 transform: scale() 属性将字体进行缩小。例如：使用 transform: scale(0.8) 即可将字体缩小为 80%。</li><li>使用 @font-face 加载小字号字体文件：可以通过 @font-face 属性加载特定的小字号字体文件，并将字体应用到相应的元素中。这样可以避免使用小于 12px 的系统默认字体。</li></ol><div class="note info flat"><p>需要注意的是，以上方法均有其局限性和兼容性问题，需要根据具体需求和浏览器支持情况来选择合适的方案。</p></div><h1 id="用纯css创建一个三角形的原理是什么？"><a href="#用纯css创建一个三角形的原理是什么？" class="headerlink" title="用纯css创建一个三角形的原理是什么？"></a>用纯css创建一个三角形的原理是什么？</h1><p>用纯 CSS 创建三角形的原理是利用 CSS 的 border 属性来实现。我们可以通过设置一个带有宽度和高度的元素，并只给它的某些边框设置颜色，来创建出三角形的形状。</p><p>具体实现方法是，使用一个正方形元素，通过设置边框宽度为 0，让其没有实际的内容；然后，通过为其中三个边框设置不同颜色，就可以实现一个三角形。</p><blockquote><p>下面是一个用 CSS 创建三角形的示例代码：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.triangle</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid <span class="hljs-number">#f00</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码片段将创建一个<mark class="hl-label red">红色</mark> 的三角形，其宽度和高度都是 0，而三角形的实际大小是由其中的边框大小来决定的。</p><p>这种方法可以轻松地实现各种形状的三角形，只需要调整边框的宽度和颜色即可。同时，由于纯 CSS 创建的三角形不需要额外的图像资源，因此它们可以更快地加载和渲染，也更方便地进行样式调整。</p><h1 id="一个满屏的品字布局，如何设计？"><a href="#一个满屏的品字布局，如何设计？" class="headerlink" title="一个满屏的品字布局，如何设计？"></a>一个满屏的品字布局，如何设计？</h1><p>一个满屏的品字布局（也称“三栏布局”）通常由一个头部导航栏、一个左侧菜单栏、一个右侧主要内容区和一个底部版权信息组成。设计它需要考虑以下几个方面：</p><ol><li>设置布局容器：通常使用一个外层容器作为品字布局的容器，并设置为100%宽度和高度。</li><li>设计头部导航栏：头部导航栏通常位于布局容器的顶部，一般使用水平菜单栏的形式展示，可以使用flexbox布局等方式。</li><li>设计左侧菜单栏：左侧菜单栏通常位于布局容器的左侧，通常采用垂直的菜单形式展示，可以使用float或者position布局等方式。</li><li>设计右侧主要内容区：右侧主要内容区通常位于布局容器的右侧，占据布局容器的大部分空间，可以使用float或者position布局等方式。</li><li>设计底部版权信息：底部版权信息通常位于布局容器的底部，一般使用居中或左对齐的形式展示，可以使用position或者flexbox布局等方式。</li><li>需要注意的是，在实现品字布局的过程中，应该尽量避免使用绝对定位、固定宽度等方法，而应该尽量使用相对布局、百分比宽度等方法，以便实现响应式布局。</li></ol><p><a href="https://shylockkai.gitee.io/shylockkai/2023/02/13/interview-css01/#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80-%E5%B7%A6%E5%8F%B3%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94">点这里</a></p><h1 id="请解释一下CSS3的flexbox-弹性盒布局模型，以及适用场景"><a href="#请解释一下CSS3的flexbox-弹性盒布局模型，以及适用场景" class="headerlink" title="请解释一下CSS3的flexbox 弹性盒布局模型，以及适用场景"></a>请解释一下CSS3的flexbox 弹性盒布局模型，以及适用场景</h1><p>CSS3 弹性盒布局（Flexbox）是一种在不同屏幕大小下更加灵活的布局方式，可以在父容器和子元素之间自动调整间距、对齐方式和元素的顺序，使得开发响应式网站变得更加容易。</p><blockquote><p>Flexbox 的适用场景包括：</p></blockquote><ol><li>多列布局：使用 Flexbox 可以轻松创建多列布局，不需要使用浮动和清除浮动等技巧。</li><li>居中对齐：使用 Flexbox 可以很方便地实现水平和垂直居中对齐，不需要使用绝对定位和负边距等技巧。</li><li>等高布局：使用 Flexbox 可以实现容器中的子元素自动平分高度，适用于多个相同高度的元素排列。</li><li>动态排列：Flexbox 可以根据容器的大小和子元素的大小自动调整元素的位置和大小，可以应用于响应式设计中。</li></ol><p>Flexbox 布局使用一组 CSS 属性来控制容器和子元素之间的布局关系，包括 flex-direction、flex-wrap、justify-content、align-items、align-content 等。其中，flex-direction 指定主轴的方向，justify-content 和 align-items 指定在主轴和交叉轴上的对齐方式，flex-wrap 控制是否允许子元素换行，align-content 控制多行元素在交叉轴上的对齐方式。<a href="https://ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a>。</p><h1 id="经常遇到的浏览器的js兼容性有哪些？解决方法是什么？"><a href="#经常遇到的浏览器的js兼容性有哪些？解决方法是什么？" class="headerlink" title="经常遇到的浏览器的js兼容性有哪些？解决方法是什么？"></a>经常遇到的浏览器的js兼容性有哪些？解决方法是什么？</h1><p>在不同的浏览器中，JavaScript 可能会存在一些不兼容的问题。以下是一些常见的浏览器兼容性问题及解决方法：</p><ol><li>不同浏览器对事件的处理方式不<blockquote><p>解决方法：使用跨浏览器的事件处理程序，如 jQuery 的事件处理程序，可以兼容大部分浏览器。</p></blockquote></li><li>不同浏览器对 XMLHTTPRequest 对象的处理方式不同<blockquote><p>解决方法：使用跨浏览器的 Ajax 库，如 jQuery 的 Ajax 库。</p></blockquote></li><li>不同浏览器对 DOM 对象的解释方式不同<blockquote><p>解决方法：使用浏览器的内置特性检测来检测浏览器是否支持某个特定的 DOM 对象或方法，并根据检测结果执行相应的代码，或使用跨浏览器的 JavaScript 库。</p></blockquote></li><li>不同浏览器对 CSS 样式的解释方式不同<blockquote><p>解决方法：使用浏览器的内置特性检测来检测浏览器是否支持某个特定的 CSS 样式或属性，并根据检测结果执行相应的代码，或使用跨浏览器的 CSS 库。</p></blockquote></li><li>不同浏览器对 ECMAScript 版本的支持不同<blockquote><p>解决方法：使用特性检测来检测浏览器是否支持某个特定的 ECMAScript 特性，并根据检测结果执行相应的代码。</p></blockquote></li><li>不同浏览器对 JSON 的解析方式不同<blockquote><p>解决方法：使用浏览器内置的 JSON 对象进行 JSON 的解析，或使用跨浏览器的 JSON 库。</p></blockquote></li><li>不同浏览器对 HTML5 标签的支持不同<blockquote><p>解决方法：使用浏览器的内置特性检测来检测浏览器是否支持某个特定的 HTML5 标签或属性，并根据检测结果执行相应的代码，或使用跨浏览器的 JavaScript 库。</p></blockquote></li></ol><h1 id="请写出多种等高布局"><a href="#请写出多种等高布局" class="headerlink" title="请写出多种等高布局"></a>请写出多种等高布局</h1><p>在 CSS 中实现等高布局有很多种方式，下面列出一些常见的方法：</p><ol><li>使用 table 布局<blockquote><p>使用<code>display: table</code>、<code>display: table-row</code>和<code>display: table-cell</code>将元素模拟成表格的布局形式，可以实现等高布局。但是这种方式的缺点是会破坏 HTML 语义，同时也不够灵活。</p></blockquote></li><li>使用浮动和负边距<blockquote><p>通过设置相同的高度和负的<code>margin</code>值，可以使多个浮动元素具有等高的效果，但是需要注意清除浮动以及父元素高度塌陷的问题。</p></blockquote></li><li>使用 flexbox 布局<blockquote><p>使用 CSS3 中的<code>flexbox</code>布局，可以实现非常灵活的等高布局。通过设置<code>display: flex</code>和<code>flex</code>属性，可以让子元素等高排列。</p></blockquote></li><li>使用绝对定位<blockquote><p>将每个子元素的<code>position</code>属性设置为<code>absolute</code>，并设置<code>top</code>和<code>bottom</code>属性，使其固定在父元素的顶部和底部。这种方式需要注意子元素的顺序以及重叠的问题。</p></blockquote></li><li>使用 grid 布局<blockquote><p>SS3 中的<code>grid</code>布局是一种二维布局方式，可以实现非常灵活的等高布局。通过设置<code>display: grid</code>和<code>grid-template-rows</code>属性，可以让子元素等高排列。</p></blockquote></li></ol><p>这里列举的只是一些常见的等高布局方式，实际上还有很多其他的方式，每种方式都有其优缺点和适用场景。</p><h1 id="浮动元素引起的问题"><a href="#浮动元素引起的问题" class="headerlink" title="浮动元素引起的问题"></a>浮动元素引起的问题</h1><h2 id="浮动元素引起的问题主要包括："><a href="#浮动元素引起的问题主要包括：" class="headerlink" title="浮动元素引起的问题主要包括："></a>浮动元素引起的问题主要包括：</h2><ol><li><p>父元素高度塌陷：当一个父元素包含了一个或多个浮动元素时，如果没有设置高度，那么父元素的高度将会塌陷为0。这是因为浮动元素脱离了正常的文档流，不再占用文档流中的位置，而父元素没有设置高度，就会根据子元素的高度来自适应高度，此时就会导致父元素高度塌陷的问题。</p></li><li><p>元素重叠：当两个或多个浮动元素在同一位置时，它们可能会发生重叠，导致页面显示不正常。</p></li><li><p>父元素宽度不自适应：当父元素包含浮动元素时，如果没有设置宽度，那么父元素的宽度可能会不自适应，导致内容溢出或者无法完全显示。</p></li><li><p>清除浮动：如果一个元素设置了浮动，而它的下一个兄弟元素没有设置清除浮动，那么后面的元素可能会受到浮动元素的影响，导致页面显示不正常。</p></li></ol><h2 id="解决浮动元素引起的问题的方法主要有："><a href="#解决浮动元素引起的问题的方法主要有：" class="headerlink" title="解决浮动元素引起的问题的方法主要有："></a>解决浮动元素引起的问题的方法主要有：</h2><ol><li><p>父元素添加 overflow: hidden;：通过为父元素设置 overflow 属性来解决父元素高度塌陷的问题。</p></li><li><p>使用 clear: both; 清除浮动：通过在浮动元素后面添加一个空元素，并为其设置 clear 属性，来清除浮动，防止后面的元素受到浮动元素的影响。</p></li><li><p>使用 clearfix：通过为父元素添加一个类，为其设置伪元素并清除浮动，来解决父元素高度塌陷的问题。</p></li><li><p>使用 flexbox 弹性布局：通过使用 flexbox 布局，可以方便地实现多列等高布局，而不需要使用浮动。</p></li><li><p>使用网格布局：通过使用 CSS 网格布局，可以实现复杂的布局结构，并且避免使用浮动。</p></li></ol><h1 id="哪些属性会导致元素脱离文档流"><a href="#哪些属性会导致元素脱离文档流" class="headerlink" title="哪些属性会导致元素脱离文档流"></a>哪些属性会导致元素脱离文档流</h1><ol><li><code>position: absolute</code>：将元素的定位方式设置为绝对定位，脱离文档流并相对于其定位父元素定位。</li><li><code>position: fixed</code>：将元素的定位方式设置为固定定位，脱离文档流并相对于视口定位。</li><li><code>float: left</code>或<code>float: right</code>：使元素浮动，脱离文档流并允许文本和行内元素环绕在周围。</li><li><code>display: none</code>：将元素隐藏，从文档流中完全移除。</li><li><code>visibility: hidden</code>：将元素隐藏，但仍占用其在文档流中的空间。</li></ol><h1 id="css优化、提高性能的方法有哪些"><a href="#css优化、提高性能的方法有哪些" class="headerlink" title="css优化、提高性能的方法有哪些"></a>css优化、提高性能的方法有哪些</h1><ol><li><p>减少CSS文件的大小：可以通过压缩CSS文件、删除不必要的空格和注释、使用CSS预处理器来减小CSS文件的大小。</p></li><li><p>使用CSS Sprites：将多个小图片合并成一张大图，然后使用CSS来控制需要显示的部分。</p></li><li><p>避免使用@import：使用@import导入CSS文件会增加页面的加载时间，最好将所有的CSS代码合并到一个文件中。</p></li><li><p>避免使用过多的选择器：选择器越复杂，匹配元素的时间就越长，最好使用ID和Class选择器。</p></li><li><p>避免使用不必要的标签：避免使用不必要的标签，如div和span，可以减少浏览器渲染时间。</p></li><li><p>使用缓存：可以使用浏览器缓存来减少页面的加载时间。</p></li><li><p>将CSS放在页面的头部：将CSS放在页面的头部可以减少页面的加载时间，因为浏览器需要先加载CSS文件才能渲染页面。</p></li><li><p>避免使用CSS表达式：CSS表达式可以使页面动态化，但会使页面的渲染时间变慢，最好避免使用。</p></li><li><p>使用字体图标：使用字体图标可以减少页面的加载时间，因为字体图标是矢量图形，可以无限放大而不会失真。</p></li><li><p>使用CSS动画：使用CSS动画可以比使用JavaScript动画更快，因为CSS动画可以在GPU上运行，而JavaScript动画只能在CPU上运行。</p></li></ol><h1 id="浏览器是怎样解析css选择器的"><a href="#浏览器是怎样解析css选择器的" class="headerlink" title="浏览器是怎样解析css选择器的"></a>浏览器是怎样解析css选择器的</h1><p>当浏览器解析CSS样式表时，它会按照<mark class="hl-label red">从右到左</mark> 的顺序解析选择器，并根据匹配规则逐步筛选元素，最终将样式应用到符合条件的元素上。</p><p>具体来说，浏览器会按照下面的步骤解析CSS选择器：</p><ol><li>从右向左匹配选择器中的每个简单选择器，直到找到一个符合条件的元素。</li><li>如果当前选择器中有后代选择器，浏览器会继续向上查找符合条件的元素，直到匹配到整个选择器。</li><li>如果当前选择器中有兄弟选择器，浏览器会在当前元素之前的所有兄弟元素中查找符合条件的元素。</li><li>如果当前选择器中有父元素选择器，浏览器会继续向上查找符合条件的元素，直到匹配到整个选择器。</li><li>如果当前选择器中有伪类或伪元素，浏览器会在匹配的元素上应用相应的效果。</li></ol><p><strong>为了提高选择器的性能，可以采用以下几个方法：</strong></p><ol><li>避免使用通配符(*)和属性选择器等性能较低的选择器。</li><li>尽量减少层级和嵌套，不要嵌套过深。</li><li>尽量使用类选择器和ID选择器，避免使用标签选择器。</li><li>避免使用后代选择器和子选择器，尽量直接使用类选择器和ID选择器。</li><li>如果需要使用复杂的选择器，可以将其拆分成多个简单的选择器。</li></ol><h1 id="margin和padding分别适合什么场景使用"><a href="#margin和padding分别适合什么场景使用" class="headerlink" title="margin和padding分别适合什么场景使用"></a>margin和padding分别适合什么场景使用</h1><p><code>margin</code>和&#96;padding都是 CSS 盒模型的组成部分，用于控制元素周围空间的大小。</p><ul><li><p><code>margin</code>用于控制元素的外边距，即元素与相邻元素之间的距离。常用于控制元素之间的间隔，使页面布局更加美观和整洁。</p></li><li><p><code>padding</code>用于控制元素的内边距，即元素内部内容与边框之间的距离。常用于控制元素内部内容的显示大小和位置，以及增加元素的可点击区域。</p></li></ul><p>一般来说，<code>margin</code>适合用于控制元素之间的距离和页面布局，而<code>padding</code>则适合用于控制元素内部内容的显示大小和位置。但是具体使用哪个，还需要根据具体的情况来决定。</p><h1 id="抽离样式模块怎么写？说出思路"><a href="#抽离样式模块怎么写？说出思路" class="headerlink" title="抽离样式模块怎么写？说出思路"></a>抽离样式模块怎么写？说出思路</h1><p>抽离样式模块的思路通常是将样式文件按照功能或者页面元素的不同特点分成多个模块，可以通过以下步骤来实现：</p><ol><li><p>确定要抽离的样式：分析样式文件中哪些是重复出现的样式，哪些是只在特定页面或特定元素中使用的样式。</p></li><li><p>抽离公共样式：将公共样式提取到独立的样式文件中，例如页面布局、通用字体大小和颜色、基本样式等。</p></li><li><p>抽离特定页面样式：将每个页面的特定样式分别提取到对应的样式文件中，这样可以避免样式冗余，提高代码的复用性。</p></li><li><p>抽离组件样式：将页面中多次出现的组件，例如按钮、表单等的样式提取到对应的组件样式文件中，这样可以避免重复编写样式，提高代码的复用性。</p></li><li><p>组合样式文件：将所有的样式文件按照功能或页面元素的不同特点进行组合，形成多个样式模块。</p></li><li><p>使用模块化的方式加载样式文件：根据需要，动态加载需要的模块，避免一次性加载所有的样式文件，降低页面的加载时间和网络带宽的占用。</p></li></ol><p>以上是一种常见的抽离样式模块的思路，可以根据实际情况和项目需要进行适当的调整和改进。</p><h1 id="元素竖向的百分比设定是相对于容器的高度吗"><a href="#元素竖向的百分比设定是相对于容器的高度吗" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗"></a>元素竖向的百分比设定是相对于容器的高度吗</h1><mark class="hl-label red">是的</mark> ，元素竖向百分比设定是相对于其包含块的高度来计算的。包含块可以是父元素、祖先元素，或者是根元素（在这种情况下，它的高度是视口的高度）。当一个元素的高度设置为百分比时，它的高度会根据其包含块的高度进行计算，因此可以实现响应式布局。同样地，使用百分比设置上下内边距、外边距等属性也是相对于容器的高度进行计算的。<h1 id="全屏滚动的原理是什么？-用到了CSS的那些属性"><a href="#全屏滚动的原理是什么？-用到了CSS的那些属性" class="headerlink" title="全屏滚动的原理是什么？ 用到了CSS的那些属性"></a>全屏滚动的原理是什么？ 用到了CSS的那些属性</h1><p>原理类似图片轮播原理，超出部分隐藏，滚动时显示即可。<br>可能用到的CSS属性：<code>overflow:hidden; transform:translate(100%, 100%); display:none;</code></p><h1 id="什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本的ie"><a href="#什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本的ie" class="headerlink" title="什么是响应式设计,响应式设计的基本原理是什么,如何兼容低版本的ie?"></a>什么是响应式设计,响应式设计的基本原理是什么,如何兼容低版本的ie?</h1><p>响应式设计（Responsive Design）是一种设计理念，旨在使网站能够适应不同屏幕大小和设备类型，为用户提供更好的体验。它的基本原理是根据设备的屏幕大小和分辨率等参数，动态调整页面布局、字体、图片和其他元素的大小和位置，以达到适配不同设备的效果。</p><p>实现响应式设计需要使用 CSS media queries（CSS 媒体查询）等技术，通过判断设备的屏幕大小，来应用不同的样式规则，以适应不同的屏幕尺寸。例如，可以根据屏幕宽度的不同，为页面设置不同的布局方式，或者使用不同大小的字体和图片等。</p><p>为了兼容低版本的 IE 浏览器，可以采用以下方法：</p><ol><li><p>使用 <a href="https://shylockkai.gitee.io/shylockkai/2023/02/14/interview-css02/#CSS-hack%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8hack">CSS hacks</a> 和条件注释：CSS hacks 是一种通过编写特定的 CSS 代码来实现对不同浏览器的适配的方法，条件注释则是一种特殊的 HTML 注释语法，可以根据浏览器版本和类型来加载不同的样式文件。</p></li><li><p>使用<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Polyfill">polyfill</a>：polyfill 是一种 JavaScript 库，可以为不支持某些新特性的浏览器提供类似的功能和表现，从而实现兼容性。常见的 polyfill 库包括 Modernizr、HTML5shiv 和 Respond.js 等。</p></li><li><p>使用框架和库：许多流行的前端框架和库，例如<a href="https://www.bootcss.com/">Bootstrap</a>、<a href="https://get.foundation/">Foundation</a>和<a href="http://www.materializecss.cn/">Materialize</a>等，都具备响应式设计的功能，可以在兼容低版本<code>IE</code>的同时，快速搭建响应式网站。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之CSS基础篇(一)</title>
      <link href="/2023/02/13/Css/interview-css01/"/>
      <url>/2023/02/13/Css/interview-css01/</url>
      
        <content type="html"><![CDATA[<h1 id="css-sprite是什么-有什么优缺点"><a href="#css-sprite是什么-有什么优缺点" class="headerlink" title="css-sprite是什么-有什么优缺点?"></a>css-sprite是什么-有什么优缺点?</h1><p><strong>CSS sprite 是一种将多个图像合并为一个单独的大图像的技术，然后使用 CSS 背景定位和剪切来呈现图像。</strong></p><mark class="hl-label green">优点</mark> <ol><li><p>减少 HTTP 请求数量：合并图像为一张大图可以减少网页中的 HTTP 请求数量，从而提高网页加载速度。</p></li><li><p>提高缓存效率：一次请求的大图比多次请求的多张小图更易缓存，从而降低网页加载时间。</p></li><li><p>减小图像文件大小：因为图像可以合并为一个单独的大图，所以文件大小也会减小。</p></li></ol><mark class="hl-label red">缺点</mark> <ol><li><p>不适合大图：如果图像文件过大，合并图像可能会导致大图加载时间过长。</p></li><li><p>不利于图像维护：如果需要更改图像，需要重新合并大图，并且需要重新修改 CSS 代码。</p></li><li><p>无法支持动态图像：CSS sprite 只适用于静态图像，对于动态图像不适用。</p></li></ol><div class="note red no-icon flat"><p>总体来说，CSS sprite 技术可以提高网页性能，但是在使用时需要注意适用情况和图像维护问题。</p></div><h1 id="display-none-与visibility-hidden-的区别"><a href="#display-none-与visibility-hidden-的区别" class="headerlink" title="display-none-与visibility-hidden-的区别?"></a>display-none-与visibility-hidden-的区别?</h1><p><code>display: none</code>和<code>visibility: hidden</code>是 CSS 中两种用于隐藏元素的方法。但它们之间有一些显著的区别：</p><ol><li><p>布局影响：<code>display: none</code>会隐藏元素，并且不占据布局空间，而<code>visibility: hidden</code>只会隐藏元素，但是仍然占据布局空间。</p></li><li><p>隐藏内容：<code>display: none</code> 不仅隐藏元素，还隐藏元素的内容，而<code>visibility: hidden</code>只隐藏元素，但是元素内容仍然可见。</p></li><li><p>隐藏交互：<code>display: none</code> 不仅隐藏元素，还隐藏元素的交互效果，而<code>visibility: hidden</code>只隐藏元素，但是元素的交互效果仍然存在。</p></li><li><p>动画效果：<code>display: none</code> 无法通过 CSS 动画效果来显示隐藏的元素，而<code>visibility: hidden</code>可以通过 CSS 动画效果来显示隐藏的元素。</p></li></ol><div class="note red no-icon flat"><p>总体来说，选择 display: none 或 visibility: hidden 取决于你想如何隐藏元素，是否希望保留元素的布局空间，以及是否希望保留元素的交互效果。</p></div><h1 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与-import的区别?"></a>link与-import的区别?</h1><p><code>&lt;link&gt;</code>和<code>@import</code>是两种用于引入 CSS 样式的方法。它们有以下不同：</p><ol><li><p>语法不同：<code>&lt;link&gt;</code>标签是 HTML 的标准标签，在 HTML 代码中直接使用，而<code>@import</code>是 CSS 的指令，在 CSS 文件中使用。</p></li><li><p>加载顺序不同：浏览器通常会先加载页面中的<code>&lt;link&gt;</code>标签指定的样式文件，然后再加载页面其他内容，而<code>@import</code>则是在页面加载完成后再加载的。</p></li><li><p>支持不同：<code>&lt;link&gt;</code>标签是 HTML5 中的标准标签，广泛支持，而<code>@import</code>只支持 CSS2 及以上版本，并不是所有浏览器都支持。</p></li><li><p>并行加载：<code>&lt;link&gt;</code>标签支持并行加载，即可以同时加载多个样式文件，而<code>@import</code>只能加载一个样式文件。</p></li></ol><div class="note red no-icon flat"><p>总体来说，<code>&lt;link&gt;</code>标签是更好的选择，因为它更常用，更好的支持，加载效率也更高。但是，如果你需要在页面加载完成后再加载样式，或者需要针对某些浏览器加载样式，则可以使用<code>@import</code>。</p></div><h1 id="什么是fouc-如何避免"><a href="#什么是fouc-如何避免" class="headerlink" title="什么是fouc?如何避免?"></a>什么是fouc?如何避免?</h1><p>FOUC 指的是 Flash of Unstyled Content，中文称为“样式瞬间消失”。这是指在页面加载过程中，由于样式文件加载慢导致页面先显示出未格式化的内容，然后才加载样式文件，造成页面样式瞬间消失的现象。<br>要避免 FOUC，可以使用以下方法：</p><ol><li><p>将 CSS 样式写入页面 head 中：这样可以保证页面加载完成前就已经加载了样式文件，避免了 FOUC 现象。</p></li><li><p>异步加载 CSS 样式：可以使用 JavaScript 来加载样式文件，这样可以避免页面加载时因样式文件的加载而影响页面的显示。</p></li><li><p>使用预处理器语言：使用预处理器语言（如 Sass）可以生成样式文件，使样式文件加载更快。</p></li><li><p>使用 CSS 雪碧图：通过将多个图片合并为一张大图，可以减少图片请求，加速页面加载速度。</p></li></ol><p>通过这些方法，可以有效避免 FOUC 现象，提高页面加载效率和用户体验。</p><h1 id="关于BFC"><a href="#关于BFC" class="headerlink" title="关于BFC"></a>关于BFC</h1><p>如何创建块级格式化上下文(block formatting context),BFC有什么用？<br>块级格式化上下文（Block Formatting Context, BFC）是 Web 页面渲染的一个概念，它是一个独立的渲染区域，内部的元素不会影响外部的元素，外部的元素也不会影响内部的元素。<br>下面是创建 BFC 的方法：</p><ol><li><p>根元素：HTML 根元素始终是一个 BFC。</p></li><li><p>float 属性：元素的 float 属性不为 none 时，该元素也是一个 BFC。</p></li><li><p>overflow 属性：元素的 overflow 属性不为 visible 时，该元素也是一个 BFC。</p></li><li><p>display 属性：元素的 display 属性为 inline-block、table-cell、table-caption、flex、grid 时，该元素也是一个 BFC。</p></li></ol><p>BFC 的用途：</p><ol><li><p>避免浮动元素影响布局：通过将父元素设置为 BFC，可以避免浮动元素影响到除它以外的元素的布局。</p></li><li><p>解决文本重叠问题：当多个浮动元素相邻时，可能会导致文本重叠，将它们包裹在 BFC 中可以避免这个问题。</p></li><li><p>解决外边距合并问题：当两个垂直相邻的块级元素具有相同的父元素时，它们的外边距会合并成一个外边距，将它们包裹在 BFC 中可以避免这个问题。</p></li></ol><p>通过理解 BFC 的作用，可以更好地解决 CSS 中的布局问题，并使用 BFC 解决浮动元素、文本重叠、外边距合并等布局问题。此外，BFC 还可以用于实现布局效果，例如创建垂直居中元素、实现多列布局等。因此，掌握 BFC 的使用是 CSS 布局的重要内容。</p><h1 id="display、float、position的关系"><a href="#display、float、position的关系" class="headerlink" title="display、float、position的关系?"></a>display、float、position的关系?</h1><p><code>display</code>、<code>float</code>和<code>position</code>是 CSS 中三个重要的布局属性，它们的关系如下：</p><ol><li><p><code>display</code>属性：它决定了元素的类型，如块级元素、行内元素等，并且影响元素的默认布局方式。</p></li><li><p><code>float</code>属性：它让元素浮动，从而实现文本环绕效果。</p></li><li><p><code>position</code>属性：它定义了元素的定位方式，是相对定位还是绝对定位，以及如何对其他元素进行定位。</p></li></ol><p>在使用这三个属性时，可以根据需要结合使用，例如，可以通过将浮动元素的 position 属性设置为 absolute，从而实现脱离文档流的布局效果。因此，了解这三个属性的关系和作用，对于 CSS 布局非常重要。</p><h1 id="清除浮动的几种方式-各自的优缺点"><a href="#清除浮动的几种方式-各自的优缺点" class="headerlink" title="清除浮动的几种方式?各自的优缺点?"></a>清除浮动的几种方式?各自的优缺点?</h1><p>清除浮动是一个非常重要的布局技巧，它的目的是确保父元素不会因为浮动的子元素高度为 0 而失去高度。有以下几种清除浮动的方式：</p><ol><li>使用<code>clear</code>属性：这是最简单的清除浮动方法，只需要在要清除浮动的元素上设置<code>clear: both</code>即可。缺点是不能用于父元素清除浮动，必须在每个需要清除浮动的元素上使用，并且不能让父元素继承子元素的浮动。</li><li>使用伪元素：通过在父元素上创建伪元素，清除浮动。这种方法是可以让父元素继承子元素的浮动的，但是会增加代码量。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用空容器：通过在父元素上创建空的容器，使用 clear: both 清除浮动。这种方法需要增加一个额外的容器，但可以让父元素继承子元素的浮动。</li><li>使用 overflow 属性：通过将父元素的 overflow 设置为 hidden 或 auto 可以清除浮动。这种方法不仅可以清除浮动，还有一些其他的效果，因此不太适用于简单的清除浮动的场景。使用 clearfix 可以解决父容器高度坍塌的问题，但是会增加 HTML 的复杂度，并且在某些情况下会导致额外的布局问题，所以对于简单的清除浮动场景使用伪元素或 overflow 属性都是更好的选择。</li></ol><h1 id="为什么要初始化css样式"><a href="#为什么要初始化css样式" class="headerlink" title="为什么要初始化css样式?"></a>为什么要初始化css样式?</h1><p>初始化CSS样式是为了保证不同的浏览器对同一网页的样式呈现保持一致。每种浏览器都有自己的默认样式，因此为了确保网页的样式在所有浏览器中看起来相似，我们需要初始化CSS样式。<br>具体来说，初始化CSS样式的过程包括以下步骤：</p><ol><li><p>重置样式：通过使用CSS重置样式库（例如normalize.css或reset.css）或手写代码，将默认样式设置为统一的基础。这可以确保不同浏览器中的样式呈现相同。</p></li><li><p>设置基本样式：设置默认字体，字号，颜色等基本样式。</p></li><li><p>设置布局样式：通过设置外边距，内边距，宽度，高度等样式来设置布局。</p></li><li><p>设置特定元素的样式：对于特定元素，例如按钮，链接，表格等，设置其特定样式。</p></li></ol><p>通过以上步骤，你可以创建一个统一的CSS初始化文件，可以在所有项目中使用，以确保所有浏览器对页面的样式呈现一致。</p><h1 id="css3有哪些新特性"><a href="#css3有哪些新特性" class="headerlink" title="css3有哪些新特性?"></a>css3有哪些新特性?</h1><p>CSS3 是 CSS（Cascading Style Sheets）的第三个版本，比 CSS2 有了很多新的特性。以下是一些常见的 CSS3 特性：</p><ol><li><p>圆角：通过 border-radius 属性可以定义元素的圆角。</p></li><li><p>阴影：通过 box-shadow 属性可以定义元素的阴影。</p></li><li><p>背景渐变：通过 background-image 和 gradient 函数可以定义元素的背景渐变。</p></li><li><p>多列布局：通过 column-count 属性可以定义元素的多列布局。</p></li><li><p>动画：通过 @keyframes 规则可以定义元素的动画。</p></li><li><p>过渡：通过 transition 属性可以定义元素的过渡效果。</p></li><li><p>媒体查询：通过 @media 规则可以定义不同的样式在不同的屏幕尺寸下。</p></li><li><p>字体：通过 @font-face 规则可以定义自定义字体。</p></li><li><p>变形：通过 transform 属性可以定义元素的变形效果。</p></li></ol><div class="note info flat"><p>这些只是 CSS3 的一些新特性，实际上还有很多其他新特性。</p></div><h1 id="display有哪些值，说明他们的作用"><a href="#display有哪些值，说明他们的作用" class="headerlink" title="display有哪些值，说明他们的作用?"></a>display有哪些值，说明他们的作用?</h1><p><code>display</code>属性是 CSS 中的一个核心属性，它用于控制元素的显示方式。它有如下几种取值：</p><ol><li><code>block</code>：元素在页面上独占一行，并且默认的宽度为它的父元素的宽度。通常用于段落、标题等元素。</li><li><code>inline</code>：元素在页面上与周围文本内容在同一行内，并且不会独占一行。通常用于文本、图片等元素。</li><li><code>inline-block</code>：元素在页面上与周围文本内容在同一行内，但是它独占一行。通常用于按钮、图片等元素。</li><li><code>none</code>：元素完全不显示，即隐藏该元素。</li><li><code>flex</code>：元素被定义为弹性布局。</li><li><code>grid</code>：元素被定义为网格布局。</li><li><code>list-item</code>：元素被定义为列表项，并且会在页面上显示一个小的点。</li></ol><p>每种值的具体作用可以根据实际需求和应用场景选择，并且每种值都有它的优点和缺点，可以根据项目需要选择最合适的显示方式。</p><h1 id="介绍一下标准的css的盒子模型-低版本ie的盒子模型有什么不同"><a href="#介绍一下标准的css的盒子模型-低版本ie的盒子模型有什么不同" class="headerlink" title="介绍一下标准的css的盒子模型,低版本ie的盒子模型有什么不同?"></a>介绍一下标准的css的盒子模型,低版本ie的盒子模型有什么不同?</h1><p>标准的CSS盒子模型是一种布局模型，它把一个HTML元素定义为一个盒子，该盒子由内容（content。）、内边距（padding）、边框（border）、外边距组成（margin）。在标准盒子模型中，盒子的总宽度 &#x3D; 左外边距 + 左边框 + 左内边距 + 内容宽度 + 右内边距 + 右边框 + 右外边距。<br>一般来说我们可以通过box-sizing属性来改变元素的盒模型，存在两个值，一个是<strong>border-box表示IE盒模型</strong>，<strong>content-box表示标准盒模型</strong>。<br>box-sizing 属性是 CSS3 中的一个属性，用于控制盒模型的计算方式。它有三个可能的值：</p><ol><li>content-box：这是默认值，表示采用标准的盒模型，即盒子的宽度 &#x3D; 内容宽度。</li><li>border-box：表示采用IE盒模型，即盒子的宽度 &#x3D; 内容宽度 + 内边距 + 边框。这样计算的好处是，盒子的宽度不受内边距和边框的影响，可以让开发者更简单地控制布局。</li><li>inherit：表示继承父元素的 box-sizing 属性值。</li></ol><p>通常情况下，我们建议使用 border-box 值，因为它更简单易用，可以避免一些布局问题。但是，有些情况下可能需要使用标准的盒模型，例如在计算内容宽度时。因此，应该根据具体需求来决定是否使用 box-sizing 属性。</p><h1 id="css优先级算法如何计算"><a href="#css优先级算法如何计算" class="headerlink" title="css优先级算法如何计算?"></a>css优先级算法如何计算?</h1><p>CSS 优先级算法是用来决定样式的最终生效值的。它通过对不同来源的样式的优先级进行比较来决定样式的最终生效值。<br>a &#x3D; 权值，a的值由两个部分组成：</p><ul><li>样式规则的特殊性（specificity）。特殊性是由选择器的各个部分（如标签名、类名、ID 名等）组成，每个部分都被赋予一定的值。特殊性越高，权值就越大。</li><li>样式规则的来源。如果两个样式规则具有相同的特殊性，那么后声明的样式规则将覆盖先声明的样式规则。</li></ul><blockquote><p>根据这个算法，最后生效的样式规则是权值最高的那个。例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-id">#header</span> <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.highlight</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight&quot;</span>&gt;</span>Hello-World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，三个样式规则的权值分别是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#header</span> <span class="hljs-selector-tag">p</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>.highlight: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>p: (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>由于第一个样式规则的权值最高，所以该样式规则将被应用到该元素上，使得文本<mark class="hl-label blue">Hello-World!</mark> 呈蓝色显示。</p><ul><li>!important &gt; 行内样式 &gt; 嵌入样式 &gt; 链接样式 &gt; 浏览器默认样式</li><li>其中，行内样式和嵌入样式具有相同的权值，而浏览器默认样式具有最低的权值。<blockquote><p>例如</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue&quot;</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>在这种情况下，样式 “color: red !important” 会<mark class="hl-label red">覆盖</mark> 行内样式 “color: blue”，因为前者具有更高的优先级。最终，段落的颜色将是红色，而不是蓝色。带有 !important 的样式具有最高的优先级，因此在使用 !important 时需要特别注意，避免影响到其他样式的生效。</p><h1 id="对bfc规范的理解"><a href="#对bfc规范的理解" class="headerlink" title="对bfc规范的理解?"></a>对bfc规范的理解?</h1><p>BFC (Block Formatting Context) 是 W3C CSS2.1 规范中的一个概念。它是一个独立的渲染区域，在这个区域内的元素布局不会影响到外面的元素。BFC 能解决一些默认布局行为导致的布局问题。</p><p>BFC 可以理解为一个独立的盒子，它具有独立的布局特性，不与外面的盒子有任何关系。例如，一个 BFC 内的浮动元素不会影响外面的布局，一个 BFC 内的外边距不会与外面的元素的外边距发生重叠。</p><p>BFC 的产生可以通过以下方式触发：</p><ol><li>根元素（<code>&lt;html&gt;</code>）</li><li>浮动元素（float 除 none 以外的值）</li><li>绝对定位元素（position 为 absolute 或 fixed）</li><li>display 为 inline-block、table-cell、table-caption、flex、grid 的元素</li><li>overflow 除了 visible 以外的值（hidden、auto、scroll）</li></ol><p>使用 BFC 能解决一些布局问题，例如：清除浮动、防止外边距重叠等。<mark class="hl-label red">但是</mark> ，也要注意到 BFC 的一些限制，例如 BFC 中的元素不能有负高度等。</p><h1 id="谈谈浮动和清除浮动"><a href="#谈谈浮动和清除浮动" class="headerlink" title="谈谈浮动和清除浮动?"></a>谈谈浮动和清除浮动?</h1><p>浮动是 CSS 中的一种布局方式，它允许元素在文档流中“浮动”，不占用它周围元素的空间。浮动元素会向左或向右移动，直到它遇到其他元素或容器的边界。</p><p>浮动元素可以用来创建复杂的布局，例如两栏布局。然而，浮动元素也可能导致一些布局问题，例如文本不能包围浮动元素。</p><p>为了解决这些问题，清除浮动是必要的。清除浮动可以使父元素包含浮动元素，以避免浮动元素对其他元素的影响。清除浮动可以通过设置父元素的“clear”属性来实现。</p><blockquote><p>常见的清除浮动的方式，例如</p></blockquote><ol><li>父元素添加clearfix：通过在父元素的样式中添加clearfix类来清除浮动。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>   <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>   <span class="hljs-attribute">display</span>: table;<br>   <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>父元素添加overflow: hidden：通过将父元素的overflow属性设为hidden来清除浮动。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>   <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用伪元素清除浮动：通过在父元素中添加伪元素来清除浮动。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:before</span>,<br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>   <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>   <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>   <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>以上三种方法都可以有效的清除浮动，使布局正确显示。</p><h1 id="CSS中position的值-relative和absolute定位原点是什么？"><a href="#CSS中position的值-relative和absolute定位原点是什么？" class="headerlink" title="CSS中position的值,relative和absolute定位原点是什么？"></a>CSS中position的值,relative和absolute定位原点是什么？</h1><p>在 CSS 中，<code>position</code>属性的值有五种：<code>static</code>，<code>relative</code>，<code>fixed</code>，<code>absolute</code>和<code>sticky</code>。<br><code>relative</code>和<code>absolute</code>是相对定位和绝对定位。</p><ul><li><code>relative</code>定位是相对定位，它相对于元素在普通流中的位置来确定元素的位置。如果不指定其他的定位属性（比如<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>），元素的位置不会发生变化。</li><li><code>absolute</code>定位是绝对定位，它的定位是相对于最近的已定位祖先元素。如果没有已定位的祖先元素，那么绝对定位的元素的位置将相对于<code>body</code>元素来确定。</li></ul><blockquote><p>例如</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: lightgray;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: lightblue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，.container 元素是一个已定位的祖先元素，.box 元素是绝对定位的元素，它相对于 .container 元素进行定位。因此，.box 元素将被定位在 .container 元素的 20 像素的上边距和 30 像素的左边距。</p><h1 id="display-inline-block-什么时候不会显示间隙"><a href="#display-inline-block-什么时候不会显示间隙" class="headerlink" title="display:inline-block,什么时候不会显示间隙?"></a>display:inline-block,什么时候不会显示间隙?</h1><p><code>display: inline-block</code>是 CSS 中的一个属性，用于设置元素的显示方式为内联块级元素。</p><p>通常情况下，当一个内联元素和一个块级元素并列时，内联元素会出现间隙。但是，如果一个元素的 “display” 属性设置为 “inline-block”，那么它将会被当作内联元素显示，并且有自己的高度和宽度，从而具有块级元素的特征。</p><p>如果不希望出现间隙，可以使用以下方法：</p><ol><li>移除空格。将元素放在同一行，消除换行符。 </li><li>设置父元素的 “font-size” 属性为 0，并将子元素的 “font-size” 属性设回合适的值。</li><li>为inline-block元素添加样式float:left。</li><li>使用margin负值。</li><li>使用 “letter-spacing” 和 “word-spacing” 属性设置合适的值，以消除间隙。</li></ol><p>后面两种方式较为麻烦，一般来说使用前三种方式即可。</p><h1 id="PNG，GIF，JPG的区别及如何选择使用"><a href="#PNG，GIF，JPG的区别及如何选择使用" class="headerlink" title="PNG，GIF，JPG的区别及如何选择使用"></a>PNG，GIF，JPG的区别及如何选择使用</h1><p>PNG、GIF、JPG 这三种图片格式各有优劣。</p><ul><li>PNG (Portable Network Graphics) 是一种无损图像格式，适用于图标、图形等透明度比较复杂的图片。</li><li>GIF (Graphics Interchange Format) 是一种有损图像格式，适用于动画、简单图形等。</li><li>JPG (Joint Photographic Experts Group,也叫JPEG) 是一种有损图像格式，适用于照片等色彩较丰富的图片。</li></ul><p>对于网页设计师来说，在选择图片格式时，要根据图片的内容和需求来决定使用哪种格式。如果需要保持图片的透明度，就使用 PNG；如果需要制作动画，就使用 GIF；如果需要展示照片，就使用 JPG。</p><h1 id="行内元素float-left后是否变为块级元素"><a href="#行内元素float-left后是否变为块级元素" class="headerlink" title="行内元素float:left后是否变为块级元素?"></a>行内元素float:left后是否变为块级元素?</h1><mark class="hl-label green">Answer:</mark> 是的，当一个行内元素使用了`float:left`后，它将变为块级元素，但保留了一些行内元素的特性，比如可以接受宽度和高度的设置。如果不需要这些特性，通常需要使用`display:block`显式地将它变为块级元素。<ul><li>行内元素设置成浮动之后变得更加像是<code>inline-block</code>（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是<code>100%</code>），这时候给行内元素设置<code>padding-top</code>和<code>padding-bottom</code>或者<code>width</code>、<code>height</code>都是有效果的。</li></ul><h1 id="在网页中应该使用奇数还是偶数的字体-为什么呢"><a href="#在网页中应该使用奇数还是偶数的字体-为什么呢" class="headerlink" title="在网页中应该使用奇数还是偶数的字体?为什么呢?"></a>在网页中应该使用奇数还是偶数的字体?为什么呢?</h1><p>常用<strong>偶数</strong>号字体,但奇数号字体也没关系,例如 知乎正文使用15px字体,豆瓣电影使用13px字体，UI设计师导出的设计稿一般都是偶数号字体，偶数字号容易和页面其他标签的其他属性形成比例关系，Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><h1 id="before和-after中双冒号和单冒号-有什么区别-解释一下这2个伪元素的作用"><a href="#before和-after中双冒号和单冒号-有什么区别-解释一下这2个伪元素的作用" class="headerlink" title="::before和:after中双冒号和单冒号,有什么区别?解释一下这2个伪元素的作用?"></a>::before和:after中双冒号和单冒号,有什么区别?解释一下这2个伪元素的作用?</h1><p>在 CSS 中，两个冒号 (::) 用于表示伪元素，而一个冒号 (:) 用于表示伪类。</p><ul><li><p><code>::before</code>和<code>::after</code>都是 CSS 中的伪元素，它们在 HTML 元素中插入内容，但不在 HTML 代码中实际出现。</p></li><li><p><code>::before</code>伪元素允许在元素的前面插入内容，而<code>::after</code>则允许在元素的后面插入内容。</p></li></ul><p>这两个伪元素可以用于在不修改 HTML 代码的情况下添加图标、箭头、背景图像、语法高亮等元素。例如，可以使用<code>::before</code>在列表项前面添加小图标，或者使用<code>::after</code>添加额外的文本或图标。</p><h1 id="如果需要手动写动画-你认为最小时间间隔是多久-为什么"><a href="#如果需要手动写动画-你认为最小时间间隔是多久-为什么" class="headerlink" title="如果需要手动写动画,你认为最小时间间隔是多久?为什么?"></a>如果需要手动写动画,你认为最小时间间隔是多久?为什么?</h1><p>CSS动画中的最小时间间隔通常是<code>1ms</code>。这是因为浏览器解析器需要每隔一段时间更新动画的状态，以保证动画流畅。如果间隔时间太长，则动画就会卡顿或者变得不够流畅。另一方面，如果间隔时间太短，则会增加浏览器的计算压力，降低整体的性能。因此，1ms是一个较为合理的间隔时间，可以保证动画的流畅性和性能。</p><p>有人说是16ms是因为这是一个关于网页动画的通俗科学，即大约每秒60帧的刷新率。大约意思是，每秒动画应该刷新60次，因此每次刷新的时间应该是16.67ms。然而，实际上，这个结论不一定适用于所有设备和浏览器，因此建议根据具体情况进行测试，以确保最佳性能。</p><h1 id="css合并方法"><a href="#css合并方法" class="headerlink" title="css合并方法?"></a>css合并方法?</h1><p>在 CSS 中，有多种方法来合并 CSS 样式:</p><ol><li><p>合并外部样式表：将多个 CSS 文件合并成一个文件，这样可以减少请求次数，提高网页的加载速度。</p></li><li><p>压缩 CSS：删除空格、注释和多余的代码，减小 CSS 文件的大小。</p></li><li><p>合并 CSS 选择器：通过使用逗号将多个选择器合并到一个声明中，减少代码量。</p></li><li><p>使用 CSS 代码库：使用 CSS 代码库，如 <a href="https://www.bootcss.com/">Bootstrap</a> 或 <a href="https://get.foundation/">Foundation</a>，可以减少重复的 CSS 代码。</p></li></ol><h1 id="css不同选择器的权重-css层叠的规则"><a href="#css不同选择器的权重-css层叠的规则" class="headerlink" title="css不同选择器的权重,css层叠的规则?"></a>css不同选择器的权重,css层叠的规则?</h1><p><a href="https://shylockkai.gitee.io/shylockkai/2023/02/13/interview-css01/#before%E5%92%8C-after%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%992%E4%B8%AA%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%9C%E7%94%A8">参考这里的讲解</a>或者这个<a href="https://www.cnblogs.com/dq-Leung/p/4213375.html">链接🔗</a></p><h1 id="列出你所知道可以改变页面布局的属性"><a href="#列出你所知道可以改变页面布局的属性" class="headerlink" title="列出你所知道可以改变页面布局的属性"></a>列出你所知道可以改变页面布局的属性</h1><p>以下是可以改变页面布局的 CSS 属性：</p><ol><li><p>display：用于控制元素的显示方式，如 block、inline、none 等。</p></li><li><p>float：用于控制元素的浮动，如 left、right、none 等。</p></li><li><p>position：用于控制元素的定位方式，如 absolute、relative、fixed 等。</p></li><li><p>top、right、bottom、left：用于控制元素的定位位置。</p></li><li><p>width、height：用于控制元素的宽度和高度。</p></li><li><p>margin：用于控制元素的外边距。</p></li><li><p>padding：用于控制元素的内边距。</p></li><li><p>overflow：用于控制元素的溢出方式，如 visible、hidden、scroll 等。</p></li><li><p>flex：用于控制元素的 Flex 布局，可以实现自适应布局。</p></li><li><p>grid：用于控制元素的 Grid 布局，可以实现网格布局。</p></li></ol><p>这些属性可以结合使用，以实现复杂的页面布局。</p><h1 id="css在性能优化方面的实践"><a href="#css在性能优化方面的实践" class="headerlink" title="css在性能优化方面的实践"></a>css在性能优化方面的实践</h1><ol><li><p>合理使用CSS选择器：避免使用不必要的继承和选择器嵌套，这样可以减少浏览器渲染的开销。</p></li><li><p>避免使用表达式：CSS表达式是动态的，浏览器必须不断地评估他们的值，这样会导致性能下降。</p></li><li><p>合理使用CSS sprites：使用CSS sprites可以减少请求图片的次数，从而提高性能。</p></li><li><p>避免使用不必要的CSS样式：不要定义不必要的CSS样式，特别是不需要的样式应该被删除。</p></li><li><p>压缩CSS文件：对CSS文件进行压缩，可以减少文件的大小，加快加载速度。</p></li></ol><p>这些都是提高CSS性能的重要实践，可以帮助开发人员获得更快的页面加载速度和更好的用户体验。这里还有补充说明<a href="https://juejin.cn/post/6844903649605320711">link</a>。</p><h1 id="css3动画-简单动画的实现-如旋转等"><a href="#css3动画-简单动画的实现-如旋转等" class="headerlink" title="css3动画,简单动画的实现,如旋转等"></a>css3动画,简单动画的实现,如旋转等</h1><p>CSS3动画是使用CSS技术制作的动画效果。它可以通过使用 @keyframes 规则来实现动画效果。<br>实现简单旋转动画的方法如下：</p><ol><li>定义 @keyframes 规则：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> rotate &#123;<br>  <span class="hljs-selector-tag">from</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>  &#125;<br>  <span class="hljs-selector-tag">to</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在 HTML 元素中使用 animation 属性：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">2s</span> infinite linear;<br>&#125;<br></code></pre></td></tr></table></figure>这里，我们定义了名为 “rotate” 的 @keyframes 规则，并使用 animation 属性在 .element 元素上调用它。该动画将旋转元素 360 度，持续 2 秒，并以线性方式无限循环。</li></ol><h1 id="Base64的原理以及优缺点？"><a href="#Base64的原理以及优缺点？" class="headerlink" title="Base64的原理以及优缺点？"></a>Base64的原理以及优缺点？</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。它将二进制数据转换为可见的ASCII字符，以便在不支持二进制数据的地方传输数据。Base64通常用于将图像、音频、视频等多媒体数据编码为文本形式，并通过HTTP传输，以及将电子邮件附件编码为文本格式，以便在不支持多媒体数据的地方传输数据。</p><p>Base64编码的<mark class="hl-label green">优点</mark> ：</p><ol><li><p>可以方便地在网络上传输二进制数据，因为Base64编码的字符是可见的。</p></li><li><p>可以方便地将二进制数据存储为文本形式，以便在不支持二进制数据的地方存储数据。</p></li></ol><p>Base64编码的<mark class="hl-label red">缺点</mark> ：</p><ol><li><p>将二进制数据转换为文本形式会导致数据增加一倍，这是因为Base64编码的字符占用3个字节的空间，而实际上只需要2个字节的空间。</p></li><li><p>由于Base64编码是一种编码方式，因此在解码时需要消耗一定的计算资源。</p></li><li><p>Base64编码不支持对二进制数据进行压缩，因此数据会增加一倍，从而影响传输效率。</p></li></ol><h1 id="几种常见的css布局"><a href="#几种常见的css布局" class="headerlink" title="几种常见的css布局"></a>几种常见的css布局</h1><h2 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a>流体布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.left</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.right</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: right;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.center</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(6, 235, 44)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(9, 134, 236)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="两栏布局-左边固定右边自适应"><a href="#两栏布局-左边固定右边自适应" class="headerlink" title="两栏布局(左边固定右边自适应)"></a>两栏布局(左边固定右边自适应)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.left-col</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>; <span class="hljs-comment">/* 高度随内容撑开 */</span> </span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.right-col</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-col&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 左边固定内容 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-col&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 右边自适应内容 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="三栏布局-左右固定中间自适应"><a href="#三栏布局-左右固定中间自适应" class="headerlink" title="三栏布局(左右固定中间自适应)"></a>三栏布局(左右固定中间自适应)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 高度随内容撑开 */</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.left-col</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: lightblue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.center-col</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: lightgreen;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.right-col</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: lightcoral;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-col&quot;</span>&gt;</span>左边栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center-col&quot;</span>&gt;</span>中间栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-col&quot;</span>&gt;</span>右边栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过设置容器为 flex 布局，将左右两栏的宽度固定为 200px，中间栏使用 flex: 1 设置自适应宽度，可以实现三栏布局的效果。</p><h2 id="三栏布局（双飞翼布局）"><a href="#三栏布局（双飞翼布局）" class="headerlink" title="三栏布局（双飞翼布局）"></a>三栏布局（双飞翼布局）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.center</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.right</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-comment">/*自身宽度*/</span></span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.left</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-comment">/*基于父元素百分比的外边距*/</span></span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(6, 235, 44)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(9, 134, 236)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>原理：给center添加一个容器元素container，设置center的margin值避开侧边栏，让left、right飘在两边</p><mark class="hl-label green">优点</mark> : 主要内容模块可以优先加载，当页面中内容较多时不会影响用户体验。<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p><strong>和与双飞翼布局的区别</strong>: 与双飞翼布局很像，有一些细节上的区别，相对于双飞翼布局来说，HTML 结构相对简单，但是样式定义就稍微复杂，也是优先加载内容主体。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.center</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.left</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.right</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    <span class="hljs-attribute">right</span>: -<span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(9, 134, 236)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(6, 235, 44)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>补充说明<a href="https://juejin.cn/post/6844903710070407182">link</a>。</p><h1 id="stylus-sass-less区别"><a href="#stylus-sass-less区别" class="headerlink" title="stylus,sass,less区别"></a>stylus,sass,less区别</h1><p>Stylus, Sass 和 Less 是三种不同的 CSS 预处理器。它们可以帮助简化 CSS 代码，以便更容易编写、维护和重用。</p><ol><li><a href="https://www.stylus-lang.cn/">Stylus</a>：Stylus 是一种强大的 CSS 预处理器，拥有简洁的语法。它具有高度可定制的特性，可以方便地实现动态样式。</li><li><a href="https://www.sasscss.com/">Sass</a>：Sass 是最流行的 CSS 预处理器之一。它具有灵活的语法，支持变量、嵌套规则、混合器、函数等高级功能。</li><li><a href="https://lesscss.com.cn/">Less</a>：Less 是一种简单的 CSS 预处理器，语法类似于 Sass，但功能较弱。它支持变量、嵌套规则、运算等功能，但不支持函数。</li></ol><p>总的来说，选择哪种 CSS 预大处理器取决于个人喜好和项目需求。如果你需要动态的、具有高度可定制性的样式，Stylus 可能是个好选择。如果你需要灵活的语法和高级功能，Sass 可能是个好选择。如果你需要一种简单、快速的 CSS 预处理器，Less 可能是个好选择。</p><h1 id="postcss的作用"><a href="#postcss的作用" class="headerlink" title="postcss的作用"></a>postcss的作用</h1><p><a href="https://www.postcss.com.cn/">PostCSS</a>是一个开源的转换工具，用于将 CSS 编译成浏览器能够读取的代码。它支持处理多种 CSS 预处理器，例如 Sass、Less、Stylus，以及各种 CSS 语言的插件。</p><p>PostCSS 的最大优点在于可以通过插件扩展功能，例如压缩代码、转换单位、添加前缀等。它可以在打包前和打包后进行代码转换，可以在 Webpack 和 gulp 等构建工具中使用，也可以作为 Node.js 库直接使用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之JS基础篇(一)</title>
      <link href="/2023/02/13/JavaScript/interview-js01/"/>
      <url>/2023/02/13/JavaScript/interview-js01/</url>
      
        <content type="html"><![CDATA[<h1 id="JS中的数据类型有哪些"><a href="#JS中的数据类型有哪些" class="headerlink" title="JS中的数据类型有哪些"></a>JS中的数据类型有哪些</h1><ol><li><p>原始类型（Primitive types）：包括数字（Number）、字符串（String）、布尔值（Boolean）、空（Null）、未定义（Undefined）、大整数（BigInt）和符号（Symbol）。</p></li><li><p>引用类型（Reference types）：包括对象（Object）、数组（Array）、函数（Function）等。</p></li></ol><p>在 ES6 中，还引入了新的数据类型：Map、Set、WeakMap、WeakSet，以及用于处理二进制数据的 ArrayBuffer、TypedArray 和 DataView 类型。</p><h1 id="介绍js有哪些内置对象"><a href="#介绍js有哪些内置对象" class="headerlink" title="介绍js有哪些内置对象"></a>介绍js有哪些内置对象</h1><p>JavaScript 中有许多内置对象，它们提供了许多有用的方法和属性，下面是一些常见的内置对象：</p><ol><li>Object：JavaScript 的基本对象，所有其他内置对象都是 Object 的后代。</li><li>Array：表示一个数组，提供了许多有用的方法来处理数组。</li><li>String：表示一个字符串，提供了许多有用的方法来处理字符串。</li><li>Number：表示一个数字，提供了许多有用的方法来处理数字。</li><li>Boolean：表示一个布尔值，即 true 或 false。</li><li>Date：表示一个日期和时间，提供了有用的方法来处理日期和时间。</li><li>Math：提供了许多数学函数和常量。</li><li>RegExp：表示一个正则表达式，提供了有用的方法来处理文本匹配。</li><li>Error：表示一个运行时错误，提供了有用的方法来处理异常。</li></ol><p>除了这些常见的内置对象之外，还有许多其他内置对象，如 Map、Set、WeakMap、WeakSet、Promise、Proxy 等。</p><h1 id="说几条写javascript的基本规范"><a href="#说几条写javascript的基本规范" class="headerlink" title="说几条写javascript的基本规范"></a>说几条写javascript的基本规范</h1><p>编写代码时遵循一定的规范和约定是很重要的，有助于提高代码质量和可读性，以下是一些编写JavaScript代码时的基本规范：</p><ol><li>使用驼峰命名法命名变量、函数和对象属性。</li><li>使用四个空格代替制表符来缩进代码。</li><li>代码中使用单引号而不是双引号。</li><li>对于代码中的魔术数值（magic number），应该使用常量或变量来代替。</li><li>使用严格相等（&#x3D;&#x3D;&#x3D;）代替松散相等（&#x3D;&#x3D;），可以避免类型转换的意外行为。</li><li>对于条件语句和循环语句的代码块，应该使用大括号包裹起来，即使代码块只有一行语句。</li><li>使用注释来解释代码的目的和实现细节，特别是一些比较复杂或难以理解的代码。</li><li>避免使用全局变量和函数，这会污染全局命名空间并可能导致命名冲突。</li><li>尽可能使用模块化的方式组织代码，避免代码的耦合度过高。</li><li>使用ES6语法中的let和const来声明变量，避免使用var。</li></ol><h1 id="谈谈闭包"><a href="#谈谈闭包" class="headerlink" title="谈谈闭包"></a>谈谈闭包</h1><p>JavaScript闭包（Closure）指的是一个函数能够访问并使用其声明时所处的作用域中的变量，即使函数被返回或传递到其他函数中执行时，依然可以访问到其声明时的作用域。具体来说，闭包是由函数以及函数内部定义的变量（即自由变量）组成的包裹体，该函数可以访问自由变量，并且自由变量的值在闭包创建时被保存下来，即使在函数执行时，自由变量的作用域已经销毁，闭包依然可以使用它们。</p><blockquote><p>下面是一个简单的闭包示例：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVariable = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVariable);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> innerFunction;<br>&#125;<br><br><span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">outerFunction</span>();<br><span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 输出&#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>innerFunction</code>函数是一个闭包，它可以访问<code>outerVariable</code>变量，即使<code>outerFunction</code>函数已经执行完毕并且作用域已经销毁。这是因为<code>innerFunction</code>函数捕获了<code>outerVariable</code>变量的引用，并将其保存在自己的作用域链中，使其能够在需要的时候被访问。</p><p>闭包可以用于很多场景，其中一些常见的用途包括：</p><ul><li>封装变量和函数：通过闭包，可以将变量和函数封装在一个私有的作用域中，从而避免命名冲突和全局污染。</li><li>保留函数的状态：通过闭包，函数可以在多次调用之间保留状态，从而实现类似于类的行为。</li><li>实现回调和异步编程：通过闭包，可以在异步操作完成后访问原始上下文中的变量和函数。</li></ul><div class="note info flat"><p>需要注意的是，闭包可能会导致内存泄漏，因为它会一直保留自由变量的引用，从而阻止垃圾回收机制对这些变量的回收。因此，在使用闭包时需要谨慎考虑内存管理问题，避免出现不必要的内存泄漏。</p></div><h1 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h1><p>作用域链是 JavaScript 中一个非常重要的概念，它描述了变量的查找方式和访问规则。当 JavaScript 引擎执行一个函数时，会为该函数创建一个新的执行上下文（Execution Context），并在该上下文中维护一个作用域链（Scope Chain）。作用域链是由当前执行上下文的变量对象和所有包含它的父级执行上下文的变量对象组成的链式结构。作用域链中的每个变量对象都包含了该执行上下文中声明的变量、函数和形参，以及它所在的上级执行上下文中声明的变量和函数。</p><p>当需要访问一个变量时，JavaScript 引擎会先从当前执行上下文的变量对象中查找该变量，如果找不到，则沿着作用域链向上查找，直到找到该变量或者到达全局执行上下文。如果还是找不到，则会抛出“未定义变量”的错误。</p><p>作用域链的顶端是全局执行上下文，也称为全局作用域，它包含了所有在全局范围内声明的变量和函数。在浏览器环境中，全局执行上下文对应的是 Window 对象，它是所有其他对象和变量的根对象。</p><p>作用域链的维护方式是在函数定义时确定的，即在函数被定义时就确定了其作用域链的结构。当函数被调用时，它的作用域链就已经确定，并在函数执行过程中保持不变。因此，作用域链是在编译阶段就被确定的，而不是在运行时动态生成的。这也是 JavaScript 中函数作为一等公民的一个体现，因为函数可以作为变量来传递和使用，而其作用域链是在定义时就确定的，可以保证函数在运行时访问到正确的变量和函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;global&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> c = <span class="hljs-string">&#x27;bar&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c);<br>  &#125;<br><br>  <span class="hljs-title function_">bar</span>();<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>在这个例子中，全局作用域中声明了一个变量<code>a</code>，值为 <code>&#39;global&#39;</code>。函数<code>foo</code>中声明了一个变量<code>b</code>，值为<code>&#39;foo&#39;</code>，并定义了一个内部函数<code>bar</code>。函数<code>bar</code>中声明了一个变量 <code>c</code>，值为<code>&#39;bar&#39;</code>。在<code>bar</code>函数中，通过<code>console.log(a, b, c)</code>打印了三个变量的值。</p><p>当<code>foo</code>函数被调用时，会创建一个新的执行上下文，并在其中维护一个作用域链。该作用域链由两个变量对象组成：当前执行上下文的变量对象和全局执行上下文的变量对象。当前执行上下文的变量对象包含了变量<code>b</code>和函数<code>bar</code>，全局执行上下文的变量对象包含了变量<code>a</code>。</p><p>当<code>bar</code>函数被调用时，会创建一个新的执行上下文，并在其中维护一个作用域链。该作用域链由三个变量对象组成：当前执行上下文的变量对象、<code>foo</code>函数执行上下文的变量对象和全局执行上下文的变量对象。当前执行上下文的变量对象包含了变量<code>c</code>，<code>foo</code>函数执行上下文的变量对象包含了变量<code>b</code>和函数<code>bar</code>，全局执行上下文的变量对象包含了变量<code>a</code>。</p><p>因此，在<code>bar</code>函数中访问变量时，会先查找当前执行上下文的变量对象，如果找不到，则沿着作用域链向上查找。在这个例子中，<code>bar</code>函数中访问的变量<code>a</code>在当前执行上下文的变量对象中不存在，因此会沿着作用域链向上查找，找到了全局执行上下文的变量对象，从而得到了变量<code>a</code>的值。变量<code>b</code>在当前执行上下文的变量对象中不存在，但在上一级<code>foo</code>函数执行上下文的变量对象中存在，因此可以通过作用域链找到变量<code>b</code>的值。变量<code>c</code>在当前执行上下文的变量对象中存在，因此可以直接访问变量<code>c</code>的值。</p><p>最终，通过<code>console.log(a, b, c)</code>打印出的结果是<code>global foo bar</code>。这就是作用域链的查找过程。</p><h1 id="javascript原型-原型链-有什么特点"><a href="#javascript原型-原型链-有什么特点" class="headerlink" title="javascript原型,原型链,有什么特点"></a>javascript原型,原型链,有什么特点</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>在 JavaScript 中，每个对象都有一个原型对象（prototype），它提供了属性和方法的继承。原型对象也是一个对象，它可以拥有自己的原型对象，因此形成了原型链（prototype chain）。</p><p>原型链是一种查找属性和方法的机制。当我们访问一个对象的属性或方法时，JavaScript 引擎会首先查找对象本身是否具有该属性或方法，如果没有，就会去查找它的原型对象是否有该属性或方法，如果还没有，就会去查找原型对象的原型对象，一直往上查找直到找到 Object.prototype（所有对象的原型链的顶端），如果在整个原型链中都没有找到该属性或方法，那么它就是 undefined。</p><p>每个对象的原型对象可以通过构造函数的 prototype 属性来设置，当我们使用构造函数创建一个新对象时，新对象的原型对象就是构造函数的 prototype 属性指向的对象。同时，原型对象中定义的属性和方法也会被新对象所继承。这种继承方式被称为原型继承。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>JavaScript 的原型链有以下特点：</p><ol><li>对象之间的继承是通过原型链实现的，每个对象都有一个原型对象，形成一个原型链。</li><li>对象可以继承其原型对象上的属性和方法。</li><li>在查找属性和方法时，如果当前对象没有该属性或方法，则会去原型对象中查找，如果原型对象也没有，则继续往上查找，直到找到 Object.prototype（所有对象的原型链的顶端<code>undefined</code>）。</li><li>对象的原型可以动态地改变，通过修改对象的原型可以影响到其所有的子孙对象。</li><li>原型链的最终端是 Object.prototype，它本身没有原型对象。</li></ol><h2 id="proto-又是什么"><a href="#proto-又是什么" class="headerlink" title="__proto__又是什么"></a>__proto__又是什么</h2><p>在 JavaScript 中，每个对象都有一个内置的属性<code>__proto__</code>，它指向该对象的原型对象。<code>__proto__</code>是一个非标准的属性，不建议在代码中直接使用，应该使用<code>Object.getPrototypeOf</code>或<code>Object.setPrototypeOf</code>方法来获取或设置对象的原型。<br>例如，对于如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br></code></pre></td></tr></table></figure><p><code>obj</code>是一个空对象，它的原型对象是<code>Object.prototype</code>。我们可以通过以下两种方式来访问<code>obj</code>的原型对象：</p><ol><li>使用 Object.getPrototypeOf 方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proto === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li>直接访问 obj 的 <strong>proto</strong> 属性（不建议使用）：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> proto = obj.<span class="hljs-property">__proto__</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proto === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ol><div class="note info flat"><p>需要注意的是，<strong>proto</strong> 属性在一些旧的浏览器中可能不被支持，而且它不是 JavaScript 规范中定义的标准属性。因此，在编写代码时，应该避免直接使用 <strong>proto</strong> 属性。</p></div><h1 id="请解释什么是事件代理"><a href="#请解释什么是事件代理" class="headerlink" title="请解释什么是事件代理?"></a>请解释什么是事件代理?</h1><p>事件代理（Event delegation）是一种常用的事件处理机制，在处理一个包含大量子元素的父元素时，我们可以把事件处理程序添加到父元素上，这样在子元素上触发事件时，事件会冒泡到父元素，从而触发父元素上的事件处理程序。</p><p>具体来说，当子元素上的事件被触发时，事件会向上冒泡到父元素，而事件代理利用这种冒泡机制来实现事件处理。通过给父元素添加事件处理程序，我们可以在父元素上监听所有子元素的事件，从而避免为每个子元素都添加事件处理程序，减少代码冗余和提高性能。</p><p>例如，下面的 HTML 代码中，有一个<code>ul</code>元素包含多个<code>li</code>子元素，我们可以使用事件代理来监听<code>li</code>元素的<code>click</code>事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用事件代理的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br><br>list.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 处理点击事件</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们在<code>ul</code>元素上添加了一个<code>click</code>事件处理程序，当用户单击其中一个<code>li</code>元素时，事件会冒泡到<code>ul</code>元素上，然后事件处理程序检查事件的目标元素是否为<code>li</code>元素，如果是，就处理点击事件。这种方式使得我们只需要在父元素上添加一个事件处理程序，就可以监听所有子元素的事件，从而简化了代码。</p><h1 id="JavaScript如何实现继承"><a href="#JavaScript如何实现继承" class="headerlink" title="JavaScript如何实现继承"></a>JavaScript如何实现继承</h1><p>在 JavaScript 中，实现继承通常有以下几种方式：</p><ol><li>原型链继承：通过让一个对象的原型指向另一个对象来实现继承。这种方式的缺点是父类的引用类型属性会被所有子类实例共享，并且在创建子类实例时无法向父类构造函数传递参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;My name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// 原型链继承</span><br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>dog.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// My name is undefined</span><br></code></pre></td></tr></table></figure></li><li>借用构造函数继承：通过在子类构造函数中调用父类构造函数来实现继承。这种方式的缺点是无法继承父类原型上的属性和方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 借用构造函数继承</span><br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog.<span class="hljs-property">name</span>); <span class="hljs-comment">// Tom</span><br></code></pre></td></tr></table></figure></li><li>组合继承：通过将原型链继承和借用构造函数继承组合起来使用，从而继承父类构造函数中的属性，并且能够继承父类原型上的属性和方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;My name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 借用构造函数继承</span><br>&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// 原型链继承</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br>dog.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// My name is Tom</span><br></code></pre></td></tr></table></figure></li><li>原型式继承：通过 Object.create() 方法复制一个对象来实现继承，可以在原型上添加一些属性和方法，然后返回这个对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> animal = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Animal&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;My name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal, &#123; <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Tom&#x27;</span> &#125; &#125;);<br><br>dog.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// My name is Tom</span><br></code></pre></td></tr></table></figure></li><li>寄生式继承：通过在一个函数内部创建一个临时对象，并将其原型指向一个对象，然后返回这个对象，从而实现继承。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnimal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">const</span> animal = &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;My name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal);<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-title function_">createAnimal</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br>dog.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// My name is Tom</span><br></code></pre></td></tr></table></figure></li><li>寄生组合式继承：通过将组合继承的缺点进行优化，从而实现继承。这种方式使用<code>Object.create()</code>方法来代替创建临时构<br>造函数的方式，从而避免了组合继承中不必要的开销和问题。<ol><li>寄生组合式继承的实现思路如下：</li><li>定义一个父类构造函数和它的原型方法；</li><li>定义一个子类构造函数，通过调用父类构造函数来继承父类的属性；</li><li>将父类原型对象的副本赋值给子类原型对象；</li><li>将子类原型对象的构造函数指向子类本身。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  prototype.<span class="hljs-property">constructor</span> = subType;<br>  subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">Child</span>, <span class="hljs-title class_">Parent</span>);<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>这里使用了 Object.create() 方法来创建一个空对象，使其原型对象指向父类的原型对象，从而实现继承。同时，为了让子类原型对象的 constructor 属性指向子类本身，需要在赋值之后手动将其指回子类。</p><h1 id="谈谈this对象的理解"><a href="#谈谈this对象的理解" class="headerlink" title="谈谈this对象的理解"></a>谈谈this对象的理解</h1><p>在 JavaScript 中，this 关键字是一个特殊的对象，它在不同的情况下会指向不同的对象。一般来说，this 的值是在函数调用时确定的，它的值取决于函数的调用方式。</p><p>以下是 this 对象的一些常见用法和理解：</p><ol><li>在全局环境下，this 指向全局对象，即 window 对象（浏览器中）或 global 对象（Node.js 中）。</li><li>在函数内部，this 指向调用该函数的对象。如果函数是作为对象的方法被调用的，this 就指向该对象。如果函数不是作为对象的方法被调用的，this 就指向全局对象。</li><li>当使用 call、apply 或 bind 方法调用函数时，this 可以被显式地绑定到指定的对象上。</li><li>当在构造函数中使用 this 时，this 指向新创建的对象实例。</li><li>箭头函数中的 this 指向定义时所在的上下文对象，而不是调用时的上下文对象。</li></ol><p>理解 this 对象的原理非常重要，因为在 JavaScript 中，函数是一等公民，而且 this 对象在面向对象编程中也扮演着重要的角色。对于 JavaScript 的面向对象编程中的继承、多态等概念的理解，都需要对 this 对象的特点有一个清晰的认识。</p><h1 id="事件模型是什么"><a href="#事件模型是什么" class="headerlink" title="事件模型是什么?"></a>事件模型是什么?</h1><p>事件模型是用于描述事件在程序中的传递和处理方式的一种模型。在Web开发中，事件模型用于描述浏览器中事件的传递和处理机制。</p><p>在标准的事件模型中，事件由浏览器依次从外向内传递，即从document对象到最内层的目标元素，然后再依次从内向外进行处理。当事件发生在某个元素上时，会依次执行该元素和它的所有父元素绑定的事件处理程序，这个过程就是事件的传递。在这个过程中，事件对象会携带一些相关的信息，比如事件类型、事件目标等。如果某个事件处理程序处理了事件，事件传递就会停止，否则事件会继续传递到下一个元素。</p><p>在事件模型中，常见的事件类型包括鼠标事件（比如click、mouseover、mouseout等）、键盘事件（比如keydown、keyup等）、表单事件（比如submit、reset等）以及窗口事件（比如load、unload、resize等）等。</p><p>为了处理事件，开发者可以使用各种方法来绑定事件处理程序，比如DOM Level 0的方式（比如直接在HTML标签中使用onclick属性）、DOM Level 2的方式（比如使用addEventListener()方法）以及IE浏览器独有的方式（比如使用attachEvent()方法）。</p><h1 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h1><p><code>new</code>操作符用于创建一个对象实例，其具体步骤如下：</p><ol><li>创建一个空对象。</li><li>将该空对象的原型指向构造函数的 prototype 属性。</li><li>执行构造函数，并将 this 绑定到该空对象上，即将构造函数的作用域赋给新对象，以便新对象可以访问构造函数中的属性和方法。</li><li>如果构造函数没有返回值或者返回一个非对象类型，那么返回该新对象；否则返回构造函数返回的对象。</li></ol><p>举个例子，假设有一个构造函数<code>Person</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old.`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要创建一个<code>Person</code>的实例对象，可以使用<code>new</code>操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>在执行 new Person(‘John’, 30) 的过程中，会创建一个空对象，然后将该空对象的原型指向 Person.prototype，接着将构造函数 Person 的 this 绑定到该空对象上，并执行构造函数中的代码，从而实现创建一个 Person 的实例对象 john。</p><p>可以通过 console.log(john) 查看 john 的具体内容。</p><h1 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h1><p>Ajax（Asynchronous JavaScript and XML）是一种在不刷新页面的情况下通过 JavaScript 向服务器发送请求并获取数据的技术。其基本原理是通过浏览器中的 XMLHttpRequest 对象，实现与服务器的异步通信。</p><p>具体步骤如下：</p><ol><li>创建 XMLHttpRequest 对象<br>在 JavaScript 中，通过创建 XMLHttpRequest 对象来实现与服务器的交互。可以使用 new 操作符创建 XMLHttpRequest 对象，如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br></code></pre></td></tr></table></figure></li><li>建立与服务器的连接<br>使用 open() 方法建立与服务器的连接。open() 方法接受三个参数：请求方式（GET 或 POST）、请求的 URL、是否异步处理请求（true 或 false）。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://example.com/api/data&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li><li>发送请求<br>使用 send() 方法向服务器发送请求。send() 方法可以接受一个参数，即要发送的数据，如果没有数据要发送，则可以将参数设置为 null。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li>接收服务器响应<br>通过监听 XMLHttpRequest 对象的 readyState 和 status 属性，可以获取服务器响应的数据。当 readyState 的值为 4 时，表示服务器响应已完成。status 属性可以获取服务器响应的状态码，一般来说，状态码为 200 表示请求成功，而其他状态码则表示请求失败。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>处理服务器响应<br>在接收到服务器响应后，可以通过 JavaScript 对返回的数据进行处理。如果服务器返回的数据是 XML 格式，可以使用 responseXML 属性；如果是文本格式，则可以使用 responseText 属性。</li></ol><p>以上就是 Ajax 的基本原理，通过异步的方式向服务器发送请求，获取数据并进行处理，而不需要刷新整个页面。</p><h1 id="如何解决跨域问题？"><a href="#如何解决跨域问题？" class="headerlink" title="如何解决跨域问题？"></a>如何解决跨域问题？</h1><p>跨域问题是由浏览器的同源策略引起的，限制了页面中的脚本只能访问同一域名下的资源。要解决跨域问题，可以采用以下方法：</p><ol><li>代理跨域请求：通过在服务器上设置代理，将请求发送到目标域名下，然后将响应返回给浏览器。</li><li>JSONP（JSON with Padding）跨域请求：利用 script 标签的跨域特性，通过在请求 URL 中添加一个 callback 参数，并将一个函数名作为参数的值传递给服务器，服务器将响应数据包装在这个函数中返回给浏览器，浏览器接收到响应后会自动执行该函数。</li><li>CORS（Cross-Origin Resource Sharing）跨域请求：通过在服务器端设置响应头部，允许指定的域名访问该服务器的资源，从而实现跨域请求。在客户端发送请求时，需要添加相应的请求头部，说明该请求是一个 CORS 请求。</li><li>WebSocket协议：WebSocket是一种新的网络协议，它可以在浏览器与服务器之间建立一条双向通信的通道，从而绕过浏览器的同源策略。</li></ol><p>需要注意的是，在使用这些方法时，需要在安全性和效率之间做出权衡，并选择合适的方法来解决跨域问题。</p><h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>模块化开发是将一个大型的应用程序拆分成一个个小的模块，以便于开发和维护。在前端开发中，常用的模块化规范有 CommonJS、AMD 和 ES6 模块等。</p><ul><li><p>在 CommonJS 规范中，一个文件就是一个模块，每个模块都有自己的作用域，模块之间的相互调用通过 require 函数和 module.exports 对象实现。</p></li><li><p>在 AMD 规范中，模块是异步加载的，可以在任何时候加载并且不会阻塞页面的渲染。模块之间的相互调用通过 define 函数和 require 函数实现。</p></li><li><p>在 ES6 模块中，模块是静态加载的，可以在编译时确定模块之间的依赖关系。模块之间的相互调用通过 import 和 export 关键字实现。</p></li></ul><p>在实际开发中，可以使用模块打包工具（如<a href="https://www.webpackjs.com/">Webpack</a>、<a href="https://www.rollupjs.com/">Rollup</a> 等）将模块打包成一个或多个文件，以便于部署和使用。同时，还可以使用一些常用的第三方模块（如 <a href="https://jquery.com/">jQuery</a>、<a href="https://www.lodashjs.com/">lodash</a>等）来加速开发进程。</p><h1 id="异步加载js的方式有哪些"><a href="#异步加载js的方式有哪些" class="headerlink" title="异步加载js的方式有哪些"></a>异步加载js的方式有哪些</h1><p>异步加载 JavaScript 脚本的方式有以下几种：</p><ol><li>使用<code>&lt;script&gt;</code>标签的<code>async</code>属性: 异步下载脚本，不影响 HTML 页面的解析，下载完成后立即执行。如下所示：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>使用<code>&lt;script</code>标签的<code>defer</code>属性: 异步下载脚本，不影响 HTML 页面的解析，但在文档完全解析和显示之后才执行。如下所示：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>动态创建<code>&lt;script&gt;</code>标签: 使用 JavaScript 在 DOM 中动态创建一个<code>&lt;script&gt;</code>标签，设置其属性 src 指向需要加载的 JavaScript 文件，然后将该标签插入到文档中。如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;example.js&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure></li><li>使用 XMLHttpRequest 对象异步加载 JavaScript 文件: 通过 XMLHttpRequest 对象发送 HTTP 请求获取 JavaScript 文件，然后通过 eval() 或者 Function() 方法将其执行。如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;example.js&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">eval</span>(xhr.<span class="hljs-property">responseText</span>);<br>  &#125;<br>&#125;;<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><div class="note info flat"><p>需要注意的是，使用 XMLHttpRequest 异步加载 JavaScript 文件的方式虽然可以实现异步加载，但有一些安全隐患，应该避免在生产环境中使用。</p></div></li></ol><h1 id="哪些操作会造成内存泄漏"><a href="#哪些操作会造成内存泄漏" class="headerlink" title="哪些操作会造成内存泄漏?"></a>哪些操作会造成内存泄漏?</h1><p>内存泄漏指的是程序中动态分配内存的操作未释放或释放不当，导致内存无法使用或被浪费的现象。在前端开发中，可能会出现以下几种情况会导致内存泄漏：</p><ol><li>意外的全局变量：在声明变量时，如果没有使用 var、const 或 let 等关键字进行声明，则该变量会自动变成全局变量，这样就会一直存在于内存中，造成内存泄漏。</li><li>未清空的定时器：定时器一旦启动就会一直执行，直到被取消或页面被卸载。如果未在适当的时候清空定时器，就会造成内存泄漏。</li><li>循环引用：当两个或多个对象彼此引用时，就会形成循环引用。如果这些对象都没有被释放，就会造成内存泄漏。</li><li>闭包：如果在函数内部定义了一个闭包，并且这个闭包引用了函数外部的变量，那么这些变量就无法被释放，也会造成内存泄漏。</li><li>DOM 元素未正确清理：如果在删除 DOM 元素时，未将其上的事件监听器和引用清除，就会造成内存泄漏。</li></ol><p>为避免内存泄漏，应该注意定期清理不再使用的对象和变量，并使用 JavaScript 开发工具进行内存泄漏检测和优化。</p><h1 id="XML和JSON的区别"><a href="#XML和JSON的区别" class="headerlink" title="XML和JSON的区别"></a>XML和JSON的区别</h1><p>XML（Extensible Markup Language）和JSON（JavaScript Object Notation）都是常见的数据交换格式，但是在一些方面它们有所不同。</p><p>以下是一些 XML 和 JSON 的主要区别：</p><ol><li>语法：XML 是一种基于标签的语言，而 JSON 是基于 JavaScript 对象的语言。</li><li>可读性：相对于 XML，JSON 具有更好的可读性和易于理解。</li><li>数据体积：相同数据的 JSON 表示通常比 XML 更小，因为 JSON 采用了紧凑的数据格式。</li><li>解析速度：由于 JSON 的结构更简单，所以解析速度比 XML 快。</li><li>数据类型：XML 可以描述任何类型的数据，而 JSON 只能表示 JavaScript 中的数据类型，如字符串、数字、布尔值、数组和对象。</li><li>扩展性：由于 XML 的灵活性，它可以支持扩展性和自定义标记，而 JSON 不支持这种灵活性。</li></ol><p>总之，JSON 更加适合在 JavaScript 中使用，因为它是基于 JavaScript 对象的语言，而 XML 更加适合用于应用程序之间的数据交换和存储。</p><h1 id="谈谈你对webpack的看法"><a href="#谈谈你对webpack的看法" class="headerlink" title="谈谈你对webpack的看法"></a>谈谈你对webpack的看法</h1><p>Webpack是一个现代化的前端打包工具，它可以将多个模块打包成一个或多个静态资源文件，同时可以处理代码中的图片、样式、字体等各种类型的资源。Webpack使用基于模块的方法，使得前端代码可以被组织成小的、独立的、可以复用的模块，从而实现了代码的可维护性和扩展性。</p><p>我的看法是，Webpack是非常强大和有用的工具。它可以帮助我们自动化构建和打包我们的前端代码，减少了手动操作的时间和出错率。使用Webpack，我们可以通过配置文件来指定各种不同的功能，例如自动编译、打包、代码分割、压缩等等。同时，Webpack社区也非常活跃，有很多的插件和工具可以帮助我们更好地使用Webpack。</p><p>当然，Webpack也有一些缺点。它的学习曲线比较陡峭，对于初学者来说可能会比较难以理解。同时，Webpack的打包速度也可能会受到一些限制，特别是在处理大型项目时。但是总的来说，Webpack是一个非常优秀的工具，可以帮助我们更好地开发和维护我们的前端代码。</p><h1 id="AMD、CMD、CommonJS、ES6"><a href="#AMD、CMD、CommonJS、ES6" class="headerlink" title="AMD、CMD、CommonJS、ES6"></a>AMD、CMD、CommonJS、ES6</h1><p>AMD、CMD、CommonJS、ES6都是JavaScript模块化规范。</p><ol><li><p>AMD（Asynchronous Module Definition）：异步模块定义，由RequireJS提出。它是浏览器端模块化的主流标准。它采用异步加载方式，模块的加载不影响后面语句的执行，可以在任何地方定义和使用模块。</p></li><li><p>CMD（Common Module Definition）：通用模块定义，由SeaJS提出。它与AMD很像，但采用同步加载方式，也是可以在任何地方定义和使用模块。</p></li><li><p>CommonJS：它是服务器端的模块化规范，Node.js采用了这个规范，使用require()、module.exports等方法来定义和导出模块。它的特点是同步加载，适合服务器环境。</p></li><li><p>ES6：ES6模块是JavaScript的官方模块化规范。它的设计思想借鉴了CommonJS和AMD，但有很多不同之处。它采用静态加载方式，即在编译时就能确定模块之间的依赖关系，使得代码的运行更加安全、效率更高。同时，它支持默认导出和命名导出两种导出方式，使得代码的可读性和可维护性更好。</p></li></ol><div class="note info flat"><p>总的来说，AMD和CMD是浏览器端的模块化规范，主要区别在于模块定义和模块加载的时机不同，适用于不同的场景。CommonJS是服务器端的模块化规范，适用于Node.js等服务器环境。ES6是JavaScript的官方模块化规范，是未来的趋势，使用更加安全、高效，而且具有更好的可读性和可维护性。</p></div><h1 id="常见web安全及防护原理"><a href="#常见web安全及防护原理" class="headerlink" title="常见web安全及防护原理"></a>常见web安全及防护原理</h1><p>Web安全是保护Web应用程序和Web服务器不受恶意攻击和利用的过程。以下是一些常见的Web安全问题和防护原理：</p><ol><li>XSS（跨站脚本攻击）：攻击者在Web页面中插入脚本，以在受害者的浏览器上运行恶意代码。防护原理：输入验证，输出编码，HTTP-only Cookie。</li><li>CSRF（跨站请求伪造）：攻击者利用受害者的身份进行操作，例如在受害者不知情的情况下从其账户中发送请求。防护原理：CSRF Token，Referer 校验。</li><li>SQL注入：攻击者通过构造恶意 SQL 语句来执行数据库操作，例如删除或插入记录。防护原理：参数化查询，输入验证。</li><li>会话劫持和会话固定：攻击者获取受害者的会话 ID，以便将其用于欺骗服务器并冒充受害者。防护原理：会话过期，使用 HTTPS，使用 Cookie HTTP-only 和 Secure 标志。</li><li>文件包含：攻击者利用 Web 应用程序的漏洞来包含本地或远程文件，例如包含密码文件。防护原理：避免使用用户控制的输入作为文件包含的参数。</li><li>点击劫持：攻击者欺骗用户点击一个看似无害的链接，实际上该链接会触发一个不良操作。防护原理：使用 X-FRAME-OPTIONS 响应头禁止嵌入。</li><li>DOS&#x2F;DDOS 攻击：攻击者利用多个计算机同时发起攻击，造成拒绝服务或使网络资源不可用。防护原理：使用反射攻击防御工具，例如DDoS 防御系统，以及合理的服务器配置和硬件升级。</li></ol><p>这些是一些常见的Web安全问题和防护原理，但并不是全部。为了确保Web应用程序的安全，我们需要综合使用多种技术和工具，进行全面的安全测试和代码审查，以发现和纠正任何潜在的漏洞。</p><h1 id="用过哪些设计模式"><a href="#用过哪些设计模式" class="headerlink" title="用过哪些设计模式"></a>用过哪些设计模式</h1><p>这里介绍一些常见的设计模式。</p><ol><li>工厂模式（Factory Pattern）：用来创建不同但相关类型对象的一种模式，用户无需关心对象的创建过程，只需关心所需产品的种类。</li><li>单例模式（Singleton Pattern）：保证一个类只有一个实例，并提供一个访问该实例的全局访问点。</li><li>观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</li><li>适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</li><li>装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更加灵活。</li><li>策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法独立于使用它的客户端而独立变化。</li></ol><p>这些设计模式都有不同的应用场景和优缺点，开发者可以根据实际需要进行选择和使用。</p><h1 id="为什么要有同源限制"><a href="#为什么要有同源限制" class="headerlink" title="为什么要有同源限制"></a>为什么要有同源限制</h1><p>同源限制是浏览器的一种安全策略，它的主要目的是为了防止恶意网站窃取用户的敏感信息或者发起跨站攻击。</p><p>同源是指协议、域名、端口号完全一致。如果两个网站不满足同源条件，就不能共享资源。同源限制防止了跨站点脚本攻击（XSS）、跨站点请求伪造（CSRF）等安全问题的发生。</p><p>举个例子，如果一个网站能够获取到另一个网站的 Cookie 信息，那么它就可以冒充用户身份，获取到用户的隐私信息。如果不进行同源限制，那么这种攻击就很容易实现。因此，同源限制是保护用户安全的重要手段之一。</p><h1 id="JavaScript有哪些方法定义对象"><a href="#JavaScript有哪些方法定义对象" class="headerlink" title="JavaScript有哪些方法定义对象"></a>JavaScript有哪些方法定义对象</h1><ol><li>对象字面量：使用大括号{}定义对象。例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;New York&#x27;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;NY&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>构造函数：使用构造函数来创建一个对象。例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; and I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&#x27; years old.&#x27;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">30</span>);<br>john.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// output: &quot;Hello, my name is John and I am 30 years old.&quot;</span><br></code></pre></td></tr></table></figure></li><li>Object.create() 方法：使用 Object.create() 方法来创建一个新对象，该对象的原型是一个已经存在的对象。例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; and I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&#x27; years old.&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br>john.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;John&#x27;</span>;<br>john.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br>john.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// output: &quot;Hello, my name is John and I am 30 years old.&quot;</span><br></code></pre></td></tr></table></figure></li><li>ES6 class：使用 class 关键字来定义一个类，并通过 constructor 方法来初始化对象。例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; and I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&#x27; years old.&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">30</span>);<br>john.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// output: &quot;Hello, my name is John and I am 30 years old.&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p>这些方法可以根据具体的场景选择使用。</p><h1 id="说说你对promise的了解"><a href="#说说你对promise的了解" class="headerlink" title="说说你对promise的了解"></a>说说你对promise的了解</h1><p>Promise 是 JavaScript 中处理异步操作的一种机制，它使得异步操作可以像同步操作一样来写，避免了回调地狱的问题。Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise 的基本用法是通过实例化 Promise 对象，传入一个 executor（执行器）函数，执行器函数中包含了异步操作，然后通过 Promise 实例对象的 then() 方法注册回调函数，当异步操作执行完成时，根据操作结果将 Promise 的状态由<code>pending</code>变为<code>fulfilled</code>或<code>rejected</code>，然后执行相应的回调函数。</p><p>Promise 还支持链式调用，即通过 then() 方法注册回调函数，然后返回一个新的 Promise 实例对象，继续调用 then() 方法，从而实现多个异步操作的串联。</p><p>在 Promise 的实现中，通过 resolve() 方法将 Promise 的状态从<code>pending</code>变为<code>fulfilled</code>，通过 reject() 方法将 Promise 的状态从<code>pending</code>变为<code>rejected</code>。同时，可以通过 Promise 的静态方法如 all()、race() 等来实现多个 Promise 实例对象的管理。</p><p>总之，Promise 在 JavaScript 异步编程中具有重要的作用，可以简化异步操作的处理流程，提高代码的可读性和可维护性。</p><h1 id="你觉得jquery源码有哪些写的好的地方"><a href="#你觉得jquery源码有哪些写的好的地方" class="headerlink" title="你觉得jquery源码有哪些写的好的地方"></a>你觉得jquery源码有哪些写的好的地方</h1><p>jQuery是一个流行的JavaScript库，其源代码有许多优秀的特性和设计。以下是一些我认为jQuery源码中写得好的地方：</p><ol><li><p>封装性：jQuery使用了良好的封装性，通过使用立即调用函数表达式（IIFE）来创建自己的作用域，避免全局变量的污染。</p></li><li><p>链式调用：jQuery的方法可以链式调用，这样可以使代码更加简洁、易读。这是通过在每个方法中返回this来实现的，以便在一个语句中调用多个方法。</p></li><li><p>兼容性：jQuery非常注重兼容性，可以运行在所有现代浏览器中，还提供了一个针对旧版本Internet Explorer的jQuery兼容版本。</p></li><li><p>事件处理：jQuery的事件处理机制是非常强大和灵活的，它支持各种事件类型，包括自定义事件、命名空间事件等。</p></li><li><p>DOM操作：jQuery提供了非常丰富的DOM操作方法，如添加、删除、修改元素等。</p></li><li><p>插件机制：jQuery提供了一个插件机制，可以让第三方开发者编写插件来扩展jQuery的功能。</p></li></ol><p>这些都是jQuery源码中写得很好的地方，使得它成为了一个非常受欢迎的JavaScript库。</p><h1 id="Vue、React、Angular"><a href="#Vue、React、Angular" class="headerlink" title="Vue、React、Angular"></a>Vue、React、Angular</h1><p>Vue、React、Angular都是目前前端开发中使用较为广泛的三个主流框架。它们都是通过组件化的方式构建复杂的用户界面，使得前端开发更加高效、简单、可维护。</p><ul><li><p>Vue是一款轻量级的渐进式框架，核心库只关注视图层的渲染，易于上手，同时拥有完善的文档和活跃的社区，便于开发者进行学习和交流。</p></li><li><p>React是一个用于构建用户界面的JavaScript库，它主要关注组件的复用和状态管理，将组件的生命周期管理得十分完善，性能也得到了极大的优化。</p></li><li><p>Angular是一个完整的框架，它提供了强大的组件化和依赖注入功能，可以方便地构建复杂的单页应用，同时提供了许多工具和框架来解决前端开发过程中的各种问题。</p></li></ul><p>这三个框架都有自己的优缺点，选择使用哪个框架要根据具体项目需求和团队技术背景等因素综合考虑。</p><h1 id="Node的应用场景"><a href="#Node的应用场景" class="headerlink" title="Node的应用场景"></a>Node的应用场景</h1><p>Node.js是基于Chrome V8引擎的JavaScript运行环境，它可以在服务器端运行JavaScript代码。因为Node.js具有事件驱动、非阻塞I&#x2F;O等特点，所以它在一些应用场景下比传统的服务器端语言（如PHP、Java等）更具有优势，一些典型的应用场景包括：</p><ol><li><p>Web应用程序：Node.js可以作为Web服务器，处理HTTP请求和响应。由于Node.js具有高效的I&#x2F;O操作，可以处理大量的并发请求，所以在构建高并发的Web应用程序时非常适合。</p></li><li><p>实时应用程序：Node.js适合构建实时应用程序，例如在线聊天室、游戏服务器等。因为Node.js能够通过WebSocket等技术进行实时双向通信。</p></li><li><p>命令行工具：Node.js可以用来构建命令行工具，例如Grunt、Gulp、Webpack等。这些工具通常用于构建、测试、打包等前端开发任务。</p></li><li><p>微服务：Node.js也适合构建微服务架构，微服务是一种将应用程序拆分为多个独立的小服务的架构模式，每个服务都有自己的独立生命周期和数据存储方式。Node.js能够轻松处理微服务中的HTTP通信和数据处理。</p></li><li><p>数据库：Node.js可以与多种数据库进行交互，例如MySQL、MongoDB、Redis等，可以用于构建数据处理和存储的应用程序。</p></li></ol><h1 id="Node和Java有什么异同点"><a href="#Node和Java有什么异同点" class="headerlink" title="Node和Java有什么异同点"></a>Node和Java有什么异同点</h1><p>Node.js 和 Java 都是非常流行的后端开发语言，虽然它们有很多不同的地方，但也有一些共同点。</p><ol><li><p>语言特点：Node.js 使用 JavaScript 作为开发语言，而 Java 则使用 Java 语言。JavaScript 是一门轻量级的语言，可以快速开发原型，但在大型应用中可能会出现维护困难的问题。Java 语言则是一门成熟的语言，其严谨的语法和强大的库使得它适合开发大型应用。</p></li><li><p>执行环境：Node.js 是在服务器端运行的 JavaScript 执行环境，而 Java 则需要依赖 JVM 执行环境。Node.js 使用单线程事件循环机制处理高并发，而 Java 使用多线程来处理并发请求。</p></li><li><p>生态系统：Java 有一个庞大的生态系统，拥有众多开发者和企业支持，Java 的框架和库非常丰富。Node.js 的生态系统也非常活跃，拥有大量的第三方库和框架，但相对于 Java 来说还是比较年轻。</p></li><li><p>应用场景：Java 通常用于开发企业级应用，如大型网站、金融系统、物流系统等。而 Node.js 适合于构建高并发、实时性要求高的应用，如实时聊天应用、实时数据交换应用等。</p></li><li><p>性能：Node.js 在处理 I&#x2F;O 密集型任务时表现优秀，而在 CPU 密集型任务上可能会表现较差。Java 的性能比 Node.js 稳定，并且在处理 CPU 密集型任务时表现更好。</p></li></ol><p>总之，Node.js 和 Java 在很多方面都有不同的优势和适用场景，需要根据具体情况进行选择。</p><h1 id="Web开发中会话跟踪的方法有哪些"><a href="#Web开发中会话跟踪的方法有哪些" class="headerlink" title="Web开发中会话跟踪的方法有哪些"></a>Web开发中会话跟踪的方法有哪些</h1><p>在 Web 开发中，会话跟踪指的是通过不同的机制跟踪用户与应用程序之间的交互过程。常见的会话跟踪方法包括：</p><ol><li>Cookie：在客户端存储少量数据，通过在 HTTP 请求和响应中携带 Cookie 来实现会话跟踪。可以设置 Cookie 的过期时间和作用域。</li><li>Session：在服务器端存储用户的会话信息，通常是一个包含用户信息的对象。在客户端与服务器端建立连接时，服务器会为每个用户创建一个唯一的 Session ID，并将其发送到客户端，以便在后续请求中进行识别。</li><li>URL 重写：将会话信息作为 URL 的一部分，通常是作为查询参数。在每个请求中都需要包含会话信息，相对于 Cookie 和 Session 的方法，URL 重写的会话跟踪方式不太安全。</li><li>HTML5 Web 存储 API：包括本地存储和会话存储。本地存储包括 localStorage 和 sessionStorage，用于存储大量数据。会话存储包括 sessionStorage 和 Web SQL，用于存储会话级别的数据。</li></ol><p>这些会话跟踪方法都有其特点和使用场景，开发者可以根据具体需求和安全性考虑选择适合的方式。</p><h1 id="eval是做什么的"><a href="#eval是做什么的" class="headerlink" title="eval是做什么的"></a>eval是做什么的</h1><p>eval() 是 JavaScript 中的一个内置函数，它的作用是将传入的字符串作为 JavaScript 代码来执行。这个函数接受一个字符串参数，并且可以解析和执行其中的 JavaScript 代码。eval() 在某些情况下可以方便地实现一些动态编程的功能，比如动态地生成函数或者执行一些动态的代码片段。</p><p>但是，由于 eval() 可以执行任意的 JavaScript 代码，包括一些恶意的代码，因此在 Web 开发中，如果没有进行足够的安全措施，使用 eval() 会存在安全隐患。在开发中，<mark class="hl-label red">尽量不要使用eval()</mark>  函数，除非你确实需要执行动态的代码片段，并且已经做好了充分的安全措施。</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置</title>
      <link href="/2023/02/10/nginx/"/>
      <url>/2023/02/10/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>Nginx 是一个非常强大的 Web 服务器，可以用于配置静态文件服务、反向代理、负载均衡等多种功能。下面是 Nginx 配置的一个简单示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Nginx"><span class="hljs-comment"># 配置 Nginx 服务器</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-comment"># 监听端口</span><br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>    <span class="hljs-comment"># 服务器域名</span><br>    <span class="hljs-attribute">server_name</span> example.com;<br><br>    <span class="hljs-comment"># 静态文件路径</span><br>    <span class="hljs-attribute">root</span> /var/www/example.com;<br>    <span class="hljs-attribute">index</span> index.html;<br><br>    <span class="hljs-comment"># 配置静态文件服务</span><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>    &#125;<br><br>    <span class="hljs-comment"># 配置错误页面</span><br>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;<br>    <span class="hljs-section">location</span> = /<span class="hljs-number">404</span>.html &#123;<br>        internal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个配置文件定义了一个 Nginx 服务器，监听端口 80，服务器域名为<code>example.com</code>，并将静态文件存储在<code>/var/www/example.com</code>目录下。</p><p>配置文件中的<code>location</code>块定义了请求的处理方式，其中，对于根路径（<code>/</code>）的请求，Nginx 将尝试寻找请求路径对应的文件或目录，如果找不到，则返回首页<code>index.html</code>。</p><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>同样地，在配置文件中还可以定义其他服务器，比如代理服务器，如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Nginx"><span class="hljs-comment"># 配置代理服务器</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-comment"># 监听端口</span><br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>    <span class="hljs-comment"># 代理服务器域名</span><br>    <span class="hljs-attribute">server_name</span> proxy.example.com;<br><br>    <span class="hljs-comment"># 配置反向代理</span><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://upstream.example.com;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>这是我的个人配置，做个备份</p></div><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span><br>&#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">8001</span>;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;<br>    <span class="hljs-attribute">server_name</span> www.010akai.top;<br>    <span class="hljs-attribute">index</span> index.php index.html index.htm default.php default.htm default.html;<br>    <span class="hljs-attribute">root</span> /www/wwwroot/;<br><br>    <span class="hljs-comment">#SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则</span><br>    <span class="hljs-comment">#error_page 404/404.html;</span><br>    <span class="hljs-comment">#HTTP_TO_HTTPS_START</span><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$server_port</span> !<span class="hljs-regexp">~ 443)</span>&#123;<br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(/.*)$</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>    &#125;<br>    <span class="hljs-comment">#HTTP_TO_HTTPS_END</span><br>    <span class="hljs-attribute">ssl_certificate</span>    /www/server/panel/vhost/cert/www.010akai.top2/fullchain.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span>    /www/server/panel/vhost/cert/www.010akai.top2/privkey.pem;<br>    <span class="hljs-attribute">ssl_protocols</span> TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span> EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">ssl_session_cache</span> shared:SSL:<span class="hljs-number">10m</span>;<br>    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">10m</span>;<br>    <span class="hljs-attribute">add_header</span> Strict-Transport-Security <span class="hljs-string">&quot;max-age=31536000&quot;</span>;<br>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">497</span>  https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;<br><span class="hljs-comment">#SSL-END</span><br><br>    <span class="hljs-comment">#ERROR-PAGE-START  错误页配置，可以注释、删除或修改</span><br>    <span class="hljs-comment">#error_page 404 /404.html;</span><br>    <span class="hljs-comment">#error_page 502 /502.html;</span><br>    <span class="hljs-comment">#ERROR-PAGE-END</span><br><br>    <span class="hljs-comment">#PHP-INFO-START  PHP引用配置，可以注释或修改</span><br>    <span class="hljs-attribute">include</span> enable-php-<span class="hljs-number">81</span>.conf;<br>    <span class="hljs-comment">#PHP-INFO-END</span><br><br>    <span class="hljs-comment">#REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效</span><br>    <span class="hljs-attribute">include</span> /www/server/panel/vhost/rewrite/www.010akai.top2.conf;<br>    <span class="hljs-comment">#REWRITE-END</span><br>    <br>    <span class="hljs-section">location</span> / &#123;<br>      <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://www.baidu.com;<br>    &#125;<br>    <br>    <span class="hljs-section">location</span> /boyu &#123;<br>      <span class="hljs-attribute">alias</span> /www/wwwroot/boyu/;<br>    <span class="hljs-attribute">index</span> index.html index.htm;<br>      <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /boyu/index.html;<br>    &#125;<br><br>    <span class="hljs-comment">#禁止访问的文件或目录</span><br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md)</span><br>    &#123;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">404</span>;<br>    &#125;<br><br>    <span class="hljs-comment">#一键申请SSL证书验证目录相关设置</span><br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.well-known</span>&#123;<br>        <span class="hljs-attribute">allow</span> all;<br>    &#125;<br><br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br>    &#123;<br>        <span class="hljs-attribute">expires</span>      <span class="hljs-number">30d</span>;<br>        <span class="hljs-attribute">error_log</span> /dev/null;<br>        <span class="hljs-attribute">access_log</span> /dev/null;<br>    &#125;<br><br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ .*\.(js|css)?$</span><br>    &#123;<br>        <span class="hljs-attribute">expires</span>      <span class="hljs-number">12h</span>;<br>        <span class="hljs-attribute">error_log</span> /dev/null;<br>        <span class="hljs-attribute">access_log</span> /dev/null;<br>    &#125;<br>    <span class="hljs-attribute">access_log</span>  /www/wwwlogs/www.010akai.top2.log;<br>    <span class="hljs-attribute">error_log</span>  /www/wwwlogs/www.010akai.top2.<span class="hljs-literal">error</span>.log;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先和深度优先</title>
      <link href="/2023/02/09/BFS&amp;DFS/"/>
      <url>/2023/02/09/BFS&amp;DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS算法（Breadth-First-Search，广度优先搜索）"><a href="#BFS算法（Breadth-First-Search，广度优先搜索）" class="headerlink" title="BFS算法（Breadth-First-Search，广度优先搜索）"></a>BFS算法（Breadth-First-Search，广度优先搜索）</h1><h2 id="BFS简介"><a href="#BFS简介" class="headerlink" title="BFS简介"></a>BFS简介</h2><p>BFS类似于树的层次遍历过程,从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</p><blockquote><p>广度优先搜索（BFS）是一种图形搜索算法，其目的是在图形中找到从起点到终点的最短路径。</p></blockquote><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>队列（先进先出）</strong></p><ol><li>创建一个空队列queue（用来存放节点）和一个空列表visit（用来存放已访问的节点）</li><li>依次将起始点及邻接点加入queue和visit中</li><li>poo出队列中最先进入的节点,从图中获取该节点的邻接点</li><li>如果邻接点不在visit中，则将该邻接点加入queue和visit中</li><li>输出pop出的节点</li><li>重复3、4、5，直至队列为空</li></ol><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><div class="note info no-icon flat"><p>待续</p></div><h2 id="代码实现-JavaScript"><a href="#代码实现-JavaScript" class="headerlink" title="代码实现(JavaScript)"></a>代码实现(JavaScript)</h2><p>下面是一个使用 JavaScript 实现的简单广度优先搜索算法的代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BFS</span>(<span class="hljs-params">graph, start, end</span>) &#123;<br>  <span class="hljs-keyword">const</span> queue = [start];<br>  <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  visited.<span class="hljs-title function_">add</span>(start);<br>  <br>  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> node = queue.<span class="hljs-title function_">shift</span>();<br><br>    <span class="hljs-keyword">if</span> (node === end) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> graph[node]) &#123;<br>      <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) &#123;<br>        visited.<span class="hljs-title function_">add</span>(neighbor);<br>        queue.<span class="hljs-title function_">push</span>(neighbor);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> graph = &#123;<br>  <span class="hljs-attr">A</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>],<br>  <span class="hljs-attr">B</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>],<br>  <span class="hljs-attr">C</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>],<br>  <span class="hljs-attr">D</span>: [<span class="hljs-string">&#x27;B&#x27;</span>],<br>  <span class="hljs-attr">E</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>],<br>  <span class="hljs-attr">F</span>: [<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>]<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">BFS</span>(graph, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在这个例子中，图形是一个字典，其中键是节点的名称，值是该节点的邻居节点的列表。队列是存储待访问节点的列表，visited 列表存储已访问的节点。</p><p>在 while 循环中，我们从队列中取出第一个节点并对其进行处理。如果该节点为终点，则返回 true。否则，我们将该节点的所有未访问邻居加入队列，并将该节点标记为已访问。在 while 循环结束后，如果未找到终点，则返回 false。</p><h1 id="DFS算法（Depth-First-Search，深度优先搜索）"><a href="#DFS算法（Depth-First-Search，深度优先搜索）" class="headerlink" title="DFS算法（Depth-First-Search，深度优先搜索）"></a>DFS算法（Depth-First-Search，深度优先搜索）</h1><h2 id="DFS简介"><a href="#DFS简介" class="headerlink" title="DFS简介"></a>DFS简介</h2><p>一种用于遍历或索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况，算法<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/210801#2">时间复杂度</a>为O(!n)。</p><blockquote><p>深度优先搜索（DFS）是一种图形搜索算法，其目的是在图形中找到从起点到终点的最短路径。</p></blockquote><p><strong>栈（先进后出）</strong></p><ol><li>创建一个空栈stack（用来存放节点）和一个空列表visit（用来存放已访问的节点）</li><li>依次将起始点及邻接点加入stack和visit中</li><li>poo出栈中最后进入的节点,从图中获取该节点的邻接点</li><li>如果邻接点不在visit中，则将该邻接点加入stack和visit中</li><li>输出pop出的节点</li><li>重复3、4、5，直至栈为空</li></ol><h2 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h2><div class="note info no-icon flat"><p>待续</p></div><h2 id="代码实现-JavaScript-1"><a href="#代码实现-JavaScript-1" class="headerlink" title="代码实现(JavaScript)"></a>代码实现(JavaScript)</h2><p>下面是一个使用 JavaScript 实现的简单深度优先搜索算法的代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DFS</span>(<span class="hljs-params">graph, node, end, visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (node === end) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <br>  visited.<span class="hljs-title function_">add</span>(node);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> graph[node]) &#123;<br>    <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor) &amp;&amp; <span class="hljs-title function_">DFS</span>(graph, neighbor, end, visited)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> graph = &#123;<br>  <span class="hljs-attr">A</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>],<br>  <span class="hljs-attr">B</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>],<br>  <span class="hljs-attr">C</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>],<br>  <span class="hljs-attr">D</span>: [<span class="hljs-string">&#x27;B&#x27;</span>],<br>  <span class="hljs-attr">E</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>],<br>  <span class="hljs-attr">F</span>: [<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>]<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">DFS</span>(graph, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在这个例子中，图形是一个字典，其中键是节点的名称，值是该节点的邻居节点的列表。visited 列表存储已访问的节点。<br>在 DFS 函数中，如果当前节点为终点，则返回 true。否则，我们将该节点标记为已访问，并递归地对其所有未访问邻居进行 DFS。如果任何一个邻居返回 true，则说明找到了终点，并返回 true。否则，返回 false。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>DFS 和 BFS 的时间复杂度和空间复杂度取决于图形的大小和结构。</p><p>DFS 的时间复杂度为 $O(n + m)，其中 $n 是图形中的节点数，$m 是图形中的边数。DFS 的空间复杂度为 $O(n)，因为我们需要存储递归调用的栈。</p><p>BFS 的时间复杂度为 $O(n + m)，与 DFS 相同。BFS 的空间复杂度为 $O(n)，因为我们需要存储队列。</p><ol><li><p>搜索的方向：DFS 和 BFS 都可以实现从源节点开始向外搜索，也可以从目标节点开始向内搜索。</p></li><li><p>节点顺序：在 BFS 中，我们通常按照距离节点的距离从小到大来访问节点，但在 DFS 中，节点的顺序通常是随机的。</p></li><li><p>空间复杂度：在大多数情况下，DFS 的空间复杂度比 BFS 的空间复杂度更高，因为它需要在递归调用中使用更多的栈空间。</p></li><li><p>可扩展性：在大型图形中，BFS 的可扩展性通常比 DFS 的可扩展性更高，因为它不需要递归调用，并且使用的空间很少。</p></li></ol><p><strong>总之，DFS 和 BFS 各有优点和缺点，因此需要根据特定情况的需求来选择合适的搜索算法。</strong></p><div class="note info flat"><p>注意：在实际应用中，DFS 的空间复杂度可能比 BFS 的空间复杂度更高，因为它通常需要记录更多的信息（例如已访问的节点），而 BFS 只需要记录当前的节点。</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT</title>
      <link href="/2023/02/08/ChatGPT/"/>
      <url>/2023/02/08/ChatGPT/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://openai.com/">ChatGPT</a>，美国“开放人工智能研究中心”研发的聊天机器人<a href="https://baike.baidu.com/reference/62446358/51749YF2cVsHwusUnSqHJaBw3iOEfDH3vXCvS3N_f8QCjpfuYrKfz52_WTgIyvC0DiSkLV3oLaKzfPT49GWZ7r23VRqjfvhWJQ">程序</a>，于2022年11月30日发布。免费。ChatGPT是<a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/9180?fromModule=lemma_inlink">人工智能</a>技术驱动的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/365730?fromModule=lemma_inlink">自然语言处理</a>工具，它能够通过学习和理解人类的语言来进行对话，还能根据聊天的<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87/2884376?fromModule=lemma_inlink">上下文</a>进行互动，真正像人类一样来聊天交流，甚至能完成撰写<a href="https://baike.baidu.com/item/%E9%82%AE%E4%BB%B6/3110293?fromModule=lemma_inlink">邮件</a>、视频<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC/399?fromModule=lemma_inlink">脚本</a>、<a href="https://baike.baidu.com/item/%E6%96%87%E6%A1%88/92610?fromModule=lemma_inlink">文案</a>、<a href="https://baike.baidu.com/item/%E7%BF%BB%E8%AF%91/32864?fromModule=lemma_inlink">翻译</a>、<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048?fromModule=lemma_inlink">代码</a>等任务。</p></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-09</p></div></div><div class='timeline-item-content'><p>目前国内用户是无法使用的，对ip有访问限制，而且开启代理后，也还需要一个能接验证码的国外手机号，想要成功注册并使用还是比较困难的。<mark class="hl-label red">But</mark> ，万能的淘宝大家可以试试，账号目前看来很便宜。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-10</p></div></div><div class='timeline-item-content'><p>今天在淘宝搜索相关内容，例如：OpenAI，ChatGPT等等词汇，已经显示不了任何内容了，看来国内对ChatGPT的相关内容进行封禁的速度和力度都很大，而且已经有很多相关文章报道高校学生或者老师使用ChatGPT来创作或者完成学业，封禁也是意料之中的事情。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-16</p></div></div><div class='timeline-item-content'><p>今日百度<a href="https://wenxin.baidu.com/">文心一言</a>发布会。<br><img src="https://s1.ax1x.com/2023/03/16/pp3xgpt.png" alt="pp3xgpt.png"></p><!-- ![pp3xgpt.png](https://cdn.jsdelivr.net/gh/shylockWu/CDN@1.0.1/Blog/assets/img/test.png) --></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS使用forEach、await、async注意事项</title>
      <link href="/2023/01/01/JavaScript_forEach_async/"/>
      <url>/2023/01/01/JavaScript_forEach_async/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>使用forEach进行循环请求数据</strong></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;0001&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>],<br>  [<span class="hljs-string">&#x27;0002&#x27;</span>, <span class="hljs-string">&#x27;peter&#x27;</span>],<br>  [<span class="hljs-string">&#x27;0003&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>],<br>]);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserName</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-comment">//模拟网络请求</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> name = userMap.<span class="hljs-title function_">get</span>(id);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(name);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> users = [<span class="hljs-string">&#x27;0001&#x27;</span>, <span class="hljs-string">&#x27;0002&#x27;</span>, <span class="hljs-string">&#x27;0003&#x27;</span>];<br>  <span class="hljs-keyword">let</span> nameArray = [];<br>  users.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">async</span> (item) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> name = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserName</span>(users[<span class="hljs-number">0</span>]);<br>    nameArray.<span class="hljs-title function_">push</span>(name);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameArray);<br>  &#125;);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameArray);<br>&#125;<br><br><span class="hljs-title function_">run</span>();<br></code></pre></td></tr></table></figure><p><img src="/images/forEach-await.png"></p><p><strong>如果使用for循环</strong></p><p><img src="/images/jsAwait.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天回顾了 async&#x2F;await 在循环语句里的使用方法，对于普通的 for-loop，所有的 await 都是串行调用的，可以放心使用，包括 while、for-in、for-of 等等；但是在有 callback 的 array 方法，如 forEach、map、filter、reduce 等等，有许多副作用，最好就别使用 await 了。当然最优解还是 Promise.all，无论从质量上还是效率上都是不二选择。</p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/01/hello-world/"/>
      <url>/2023/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
